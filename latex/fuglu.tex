% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}


\title{fuglu Documentation}
\date{October 18, 2013}
\release{1}
\author{gryphius}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


Contents:


\chapter{Overview}
\label{overview-index:overview}\label{overview-index:fuglu-mail-content-scanner}\label{overview-index::doc}
Fuglu is a mail scanner daemon written in python. Installed as a postfix before-queue or after-queue filter fuglu can be used to filter spam, viruses, unwanted attachments etc.

Fuglu's simple plugin architecture allows extending functionality easily (basic python skills required).


\section{Features}
\label{overview-index:features}
Fuglus features include
\begin{itemize}
\item {} 
Virus Scanning ( clamav / sophos / f-prot / .... )

\item {} 
Spam Filter ( spamassassin )

\item {} 
Mail Archive

\item {} 
Attachment Blocker, with global/domain/individual rules

\item {} 
Different behaviour for outgoing mail (eg. don't scan for spam but scan for viruses)

\item {} 
statistics (performance mrtg graphs, spam/ham , viruses , ...)

\end{itemize}


\chapter{Installation}
\label{installation-index:installation}\label{installation-index::doc}

\section{Prerequisites}
\label{installation-index:prerequisites}

\subsection{required}
\label{installation-index:required}\begin{itemize}
\item {} 
\textbf{python} (\textgreater{}=2.4)

\item {} 
\textbf{python-setuptools}

\item {} 
\textbf{postfix}

\end{itemize}


\subsection{recommended}
\label{installation-index:recommended}\begin{itemize}
\item {} 
\textbf{python-file} (the file magic bindings) - Without this the attachment checker will only be able to block based on content type/attachment name but not based on the real file content.

\item {} 
\textbf{Spamassassin Daemon (spamd)} ( if you don't have/want this, you need to disable it in the configuration, see below)

\item {} 
\textbf{Clam Antivirus Daemon (clamd)} ( if you don't have/want this, you need to disable it in the configuration, see below)

\end{itemize}


\section{Getting and installing Fuglu}
\label{installation-index:getting-and-installing-fuglu}

\subsection{cloning source from github}
\label{installation-index:cloning-source-from-github}
\begin{Verbatim}[commandchars=\\\{\}]
git clone https://github.com/gryphius/fuglu.git
cd fuglu/fuglu
python setup.py install
\end{Verbatim}


\subsection{latest source package from github}
\label{installation-index:latest-source-package-from-github}
\begin{Verbatim}[commandchars=\\\{\}]
wget https://github.com/gryphius/fuglu/tarball/master -O fuglu-latest.tar.gz
tar -xvzf fuglu-latest.tar.gz
cd cd gryphius-fuglu-*
python setup.py install
\end{Verbatim}


\subsection{latest released package from pypi}
\label{installation-index:latest-released-package-from-pypi}
\begin{Verbatim}[commandchars=\\\{\}]
pip install fuglu
\end{Verbatim}


\chapter{Configuration}
\label{configuration-index:configuration}\label{configuration-index::doc}
Contents:


\section{Basic Configuration}
\label{configuration-index:basic-configuration}

\subsection{Fuglu}
\label{configuration-index:fuglu}
First of all, rename remove the .dist ending from all files in \code{/etc/fuglu}, so you have a basic default configuration.

edit \code{/etc/fuglu/fuglu.conf} and change parameters if you like

Note: If you don't have Clamav (clamd) or Spamassassin (spamd) , you need to remove those entries from the plugins option.

eg, change

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{plugins}\PYG{o}{=}\PYG{n}{archive}\PYG{p}{,}\PYG{n}{attachment}\PYG{p}{,}\PYG{n}{clamav}\PYG{p}{,}\PYG{n}{spamassassin}
\end{Verbatim}

to

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{plugins}\PYG{o}{=}\PYG{n}{archive}\PYG{p}{,}\PYG{n}{attachment}
\end{Verbatim}

to disable both Antispam and Antivirus.

Make sure the logging directory exists:

\begin{Verbatim}[commandchars=\\\{\}]
mkdir -p /var/log/fuglu
chown nobody /var/log/fuglu
\end{Verbatim}

Then check if fuglu is happy with your configuration:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{fuglu} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{lint}
\end{Verbatim}

example:

\begin{Verbatim}[commandchars=\\\{\}]
fuglu --lint

Fuglu \$Id: core.py 7 2009-04-09 06:51:25Z oli \$
---------- LINT MODE ----------
Loading plugins...
Plugin loading complete
Linting  main configuration
OK

Linting Plugin  ArchivePlugin
OK

Linting Plugin  Attachment Blocker
OK

Linting Plugin  ClamavPlugin
Got Pong: PONG

Clamav found virus \PYGZob{}'stream': 'Eicar-Test-Signature FOUND'\PYGZcb{}
OK

Linting Plugin  SAPlugin
Got: SPAMD/1.4 0 PONG

GTUBE Has been detected correctly
OK

Linting Plugin  MessageDebugger
OK

Linting Plugin  PluginSkipper
OK

0 plugins reported errors.
\end{Verbatim}

If all went fine, run \code{fuglu} without parameters to start the daemon.
in \code{/var/log/fuglu/fuglu.log} you should then see output similar to this:

\begin{Verbatim}[commandchars=\\\{\}]
tail /var/log/fuglu/fuglu.log
2009-04-16 16:14:54,738 root        : INFO Dropping Privileges. Before: root(0)/root(0) After: nobody(99)/nobody(99)
2009-04-16 16:14:54,739 fuglu.plugin.FiletypePlugin.RulesCache: INFO Loaded 0 rules from 2 files
2009-04-16 16:14:54,739 fuglu.MainController: INFO Init Stat Engine
2009-04-16 16:14:54,740 fuglu.MainController: INFO Init Threadpool
2009-04-16 16:14:54,740 fuglu.MainController: INFO Init SMTP Engine
2009-04-16 16:14:54,741 fuglu.MainController: INFO Startup complete
2009-04-16 16:14:54,742 fuglu.smtp.incoming.10025: INFO SMTP Server running on port 10025
2009-04-16 16:14:54,743 fuglu.smtp.incoming.10099: INFO SMTP Server running on port 10099
2009-04-16 16:14:54,743 fuglu.smtp.incoming.10888: INFO SMTP Server running on port 10888
\end{Verbatim}

fuglu comes with a few example init scripts if you want to start fuglu like other system daemons


\subsection{Postfix}
\label{configuration-index:postfix}
Once fuglu is up and running, we need to tell Postfix to use it as an after queue filter.

Detailed documentation is available on the \href{http://www.postfix.org/FILTER\_README.html}{postfix} website, but here is a quick example.

here is a quick example.

add to \code{master.cf} :

\begin{Verbatim}[commandchars=\\\{\}]
\#fuglu
fuglu\_default   unix  -       -       n       -       10      smtp
        -o smtp\_send\_xforward\_command=yes
        -o disable\_mime\_output\_conversion=yes

fuglu\_trusted   unix  -       -       n       -       10      smtp
        -o smtp\_send\_xforward\_command=yes
        -o disable\_mime\_output\_conversion=yes

\#
localhost:10026 inet  n       -       n       -       10      smtpd
        -o content\_filter=
        -o receive\_override\_options=no\_unknown\_recipient\_checks,no\_header\_body\_checks,no\_milters,no\_address\_mappings
        -o smtpd\_helo\_restrictions=
        -o smtpd\_client\_restrictions=
        -o smtpd\_sender\_restrictions=
        -o smtpd\_recipient\_restrictions=permit\_mynetworks,reject
        -o mynetworks=127.0.0.0/8
        -o smtpd\_authorized\_xforward\_hosts=127.0.0.0/8
\end{Verbatim}

This creates two filters \code{fuglu\_trusted} for outgoing mail and \code{fuglu\_default} for incoming mail. An additional postfix instance will listen on port \emph{10026} where fuglu can re-inject filtered messages.

create a new file \code{/etc/postfix/filter\_default}

\begin{Verbatim}[commandchars=\\\{\}]
\# filter for others
/./ FILTER fuglu\_default:[127.0.0.1]:10025
\end{Verbatim}

this tells postfix to send untrusted messages to fuglu on port 10025

create a new file \code{/etc/postfix/filter\_trusted}

\begin{Verbatim}[commandchars=\\\{\}]
\# filter for authenticated users
/./ FILTER fuglu\_trusted:[127.0.0.1]:10099
\end{Verbatim}

this tells postfix to send trusted (outgoing) mail to fuglu on port 10099. Fuglu can be configured to treat outgoing mail differently, eg. skip spam scanning but keep antivirus scanning

in \code{main.cf} add

\begin{Verbatim}[commandchars=\\\{\}]
smtpd\_recipient\_restrictions =  check\_client\_access pcre:/etc/postfix/filter\_trusted,
                                                                permit\_sasl\_authenticated,
                                                                permit\_mynetworks,
                                                                reject\_unauth\_destination,
                                                                pcre:/etc/postfix/filter\_default

fuglu\_trusted\_destination\_recipient\_limit=1
fuglu\_default\_destination\_recipient\_limit=1
\end{Verbatim}

run \code{postfix reload} and check your maillog for errors. from now on, messages should be filtered by fuglu!


\section{Advanced Config}
\label{configuration-index:advanced-config}

\subsection{Running a plugin multiple times with different config sections}
\label{configuration-index:running-a-plugin-multiple-times-with-different-config-sections}
By default, plugins search your configfile for a section named like the Plugin itself, for example, the ArchivePlugin looks for a {[}ArchivePlugin{]} section. This can be overridden which allows running plugin multiple times per scan with different config options:

example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{plugins}\PYG{o}{=}\PYG{n}{archive}\PYG{p}{(}\PYG{n}{ArchiveConfig1}\PYG{p}{)}\PYG{p}{,}\PYG{n}{spamassassin}\PYG{p}{,}\PYG{n}{clamav}\PYG{p}{,}\PYG{n}{archive}\PYG{p}{(}\PYG{n}{ArchiveConfig2}\PYG{p}{)}

\PYG{p}{[}\PYG{n}{ArchiveConfig1}\PYG{p}{]}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}

\PYG{p}{[}\PYG{n}{ArchiveConfig2}\PYG{p}{]}
\end{Verbatim}


\subsection{Fuglu in Before-Queue Mode}
\label{configuration-index:fuglu-in-before-queue-mode}
The fuglu ESMTP Connector enables fuglu to run in before-queue mode, i.e. while the smtp session with the remote system is still active. This allows  rejecting spam / infected mails for example.

\textbf{Postfix config}:
edit \code{master.cf} as described in \href{http://www.postfix.org/SMTPD\_PROXY\_README.html}{http://www.postfix.org/SMTPD\_PROXY\_README.html}

\begin{Verbatim}[commandchars=\\\{\}]
\# Before-filter SMTP server. Receive mail from the network and
\# pass it to the content filter on localhost port 10025.
\#
smtp      inet  n       -       n       -       20      smtpd
    -o smtpd\_proxy\_filter=127.0.0.1:10025
    -o smtpd\_client\_connection\_count\_limit=10
    \# Postfix 2.7 and later performance feature.
    \# -o smtpd\_proxy\_options=speed\_adjust
\#
\# After-filter SMTP server. Receive mail from the content filter
\# on localhost port 10026.
\#
127.0.0.1:10026 inet n  -       n       -        -      smtpd
    -o smtpd\_authorized\_xforward\_hosts=127.0.0.0/8
    -o smtpd\_client\_restrictions=
    -o smtpd\_helo\_restrictions=
    -o smtpd\_sender\_restrictions=
    -o smtpd\_recipient\_restrictions=permit\_mynetworks,reject
    -o smtpd\_data\_restrictions=
    -o mynetworks=127.0.0.0/8
    -o receive\_override\_options=no\_unknown\_recipient\_checks
\end{Verbatim}

fuglu config:

enable the esmtp connector on the incoming port (10025) in \code{/etc/fuglu/fuglu.conf}:

\begin{Verbatim}[commandchars=\\\{\}]
incomingport=esmtp:10025,10099,10888
\end{Verbatim}

\textbf{rejecting spam}:

in the fuglu configuration set \code{DEFAULTHIGHSPAMACTION=REJECT} (do the same for \code{DEFAULTLOWSPAMACTION} if you want to reject all spam). in the Spamassassin Pluginconfiguration, you can configure a custom reject message which supports various template variables:
\begin{itemize}
\item {} 
\emph{\$\{from\_address\}} : sender address

\item {} 
\emph{\$\{to\_address\}} : recipient address

\item {} 
\emph{\$\{from\_domain\}} : sender domain

\item {} 
\emph{\$\{to\_domain\}} : recipient domain

\item {} 
\emph{\$\{subject\}} : message subject

\item {} 
\emph{\$\{spamscore\}} : spamassassin score

\item {} 
\emph{\$\{date\}} : current date

\item {} 
\emph{\$\{time\}} : current time

\end{itemize}

Esample:

\begin{Verbatim}[commandchars=\\\{\}]
rejectmessage=message from \$\PYGZob{}from\_address\PYGZcb{} to \$\PYGZob{}to\_domain\PYGZcb{} identified as spam (score=\$\PYGZob{}spamscore\PYGZcb{})
\end{Verbatim}

\textbf{rejecting viruses}:

this works the same way as rejecting spam, by setting \code{DEFAULTVIRUSACTION=REJECT} and configuring the \code{rejectmessage} in the antivirus plugin section.

\textbf{Example fuglu configuration}

With this example pre-queue configuration fuglu will scan for spam, virus and blocked attachments. low spam will be tagged, high spam (level\textgreater{}=10) will be rejected.

\begin{Verbatim}[commandchars=\\\{\}]
[main]
plugins=attachment,clamav,spamassassin
incomingport=esmtp:10025,10099,10888

[spam]
DEFAULTLOWSPAMACTION=DUNNO
DEFAULTHIGHSPAMACTION=REJECT

[virus]
DEFAULTVIRUSACTION=REJECT

[FiletypePlugin]
sendbounce=0
blockaction=REJECT

[SAPlugin]
rejectmessage=Sorry, this message looks like spam to me!
highspamlevel=10
\end{Verbatim}


\subsection{Running fuglu as a milter}
\label{configuration-index:running-fuglu-as-a-milter}
!! Warning, this is an EXPERIMENTAL feature - untested, may or may not work !!

!! Note: fuglu milter does not currently support message header/body modification, just actions like REJECT/DEFER/DISCARD !!

To run fuglu as a milter, add \code{milter:\textless{}portnumber} to the \code{incomingport} configuration option in fuglu.conf.

\begin{Verbatim}[commandchars=\\\{\}]
incomingport=10025,10099,10888,milter:10028
\end{Verbatim}

then enable milters in your MTA. postfix example (main.cf) :

\begin{Verbatim}[commandchars=\\\{\}]
milter\_protocol = 2
milter\_default\_action = accept
milter\_content\_timeout = 30s
smtpd\_milters=inet:127.0.0.1:10028
\end{Verbatim}


\subsection{Running fuglu in netcat-mode}
\label{configuration-index:running-fuglu-in-netcat-mode}
fuglu supports message processing by simply ``piping'' them into a socket. To enable this socket, add \code{netcat:\textless{}portnumber\textgreater{}} to the \code{incomingport} configuration option in fuglu.conf.

\begin{Verbatim}[commandchars=\\\{\}]
incomingport=10025,10099,10888,netcat:20099
\end{Verbatim}

when restarting fuglu, you should see something like \code{INFO NETCAT Server running on port 20099} in the logs. you may then pipe an eml from the shell

\begin{Verbatim}[commandchars=\\\{\}]
(sleep 0.1; cat eicar.eml) \textbar{} nc -c localhost 20099
\end{Verbatim}

in some special setups, people use fuglu as an after-delivery filter with this method.

example procmail filter:

\begin{Verbatim}[commandchars=\\\{\}]
\# netcat send msg copy to fuglu
:0c
\textbar{} nc localhost 20099
\end{Verbatim}

Note: in netcat mode fuglu only receives message headers and body, no envelope data. Fuglu will assign the dummy value \code{unknown@example.org} for both envelope sender and recipient.


\subsection{Fetching scan-time configuration values from a database}
\label{configuration-index:fetching-scan-time-configuration-values-from-a-database}
(experimental feature) It is now possible to fetch certain configuration options at runtime, based on the recipient email address or domain.

For this to work you need to have sqlalchemy installed ( running \emph{fuglu --lint} should show \emph{enabled} for the sql extension)

SQL script to create the the table:

\begin{Verbatim}[commandchars=\\\{\}]
CREATE TABLE {}`fugluconfig{}` (
  {}`scope{}` varchar(255) NOT NULL,
  {}`section{}` varchar(255) NOT NULL,
  {}`option{}` varchar(255) NOT NULL,
  {}`value{}` varchar(255) NOT NULL,
  PRIMARY KEY (scope,section,option)
)
\end{Verbatim}

The process is very similar to spamassassin's SQL configuration  (\href{http://wiki.apache.org/spamassassin/UsingSQL}{http://wiki.apache.org/spamassassin/UsingSQL} ), with a few minor differences:
\begin{itemize}
\item {} 
we require two columns to identify a preference: \emph{section} and \emph{option}

\item {} 
username is called \emph{scope}

\item {} 
fuglu does not load the full configuration per user, only the actual config options requested by plugins supporting db overrides

\end{itemize}

enable configuration lookups by providing a standard sql alchemy connectstring in you configuration (section \emph{databaseconfig} option \emph{dbconnectstring})

\begin{Verbatim}[commandchars=\\\{\}]
[databaseconfig]
dbconnectstring=mysql://root@localhost/fuglu
\end{Verbatim}

if you use the above table structure in MariaDB / MySQl, the built-in default sql statement should work, but you may use a custom statement (\emph{sql=SELECT ....} in the same section.  ) use \emph{:section}, \emph{:option} and the usual suspect variables like \emph{:to\_domain} and \emph{:to\_address} as placeholders.

Note: only the Spamassassin plugin currently supports reading database overrides, for the following options: \emph{lowspamaction}, \emph{highspamaction}, \emph{highspamlevel}


\chapter{Operation}
\label{operation-index:operation}\label{operation-index::doc}

\section{Monitoring}
\label{operation-index:monitoring}
Fuglu has various places where you can see what it is is currently doing (eg. for debugging purposes) or what it has done (for statistical analysis)


\subsection{Command Line Interface}
\label{operation-index:command-line-interface}
The \code{fuglu\_control} command offers various options to get real-time information on fuglu internals

\textbf{statistics:}

\begin{Verbatim}[commandchars=\\\{\}]
\#\$ fuglu\_control stats
Fuglu statistics
---------------
Uptime:         19:33:56.119661
Avg scan time:  3.9657
Total msgs:     86667
Ham:            547
Spam:           86124
Virus:          8
\end{Verbatim}

\textbf{Status of currently running scanner threads:}

\begin{Verbatim}[commandchars=\\\{\}]
\#fuglu\_control workerlist
Total 10 Threads

[98]: Suspect 8790fa16a3733350baf02d5b4e7d98e1: from=\textless{}redacted\textgreater{} to=\textless{}redacted\textgreater{} size=1043 , spam=no, virus=no tags=\PYGZob{}'virus': \PYGZob{}'F-Prot': False, 'ClamAV': False\PYGZcb{}, 'FprotPlugin.time': '0.0080', 'spam': \PYGZob{}\PYGZcb{}, 'incomingport': 10025, 'decisions': [('F-Prot Plugin', 0), ('ClamavPlugin', 0)], 'ClamavPlugin.time': '0.0055'\PYGZcb{} : Running Plugin SAPlugin
*******
[99]: Suspect b6f3019df4da4170888e144f98eaa3ad: from=\textless{}redacted\textgreater{} to=\textless{}redacted\textgreater{} size=5187 , spam=no, virus=no tags=\PYGZob{}'virus': \PYGZob{}'F-Prot': False, 'ClamAV': False\PYGZcb{}, 'FprotPlugin.time': '0.0088', 'spam': \PYGZob{}\PYGZcb{}, 'incomingport': 10025, 'decisions': [('F-Prot Plugin', 0), ('ClamavPlugin', 0)], 'ClamavPlugin.time': '0.0161'\PYGZcb{} : Running Plugin SAPlugin
*******
[100]: waiting for task
*******
[101]: Suspect eefa38e4ae4a9c2938670a46d6b2b922: from=\textless{}redacted\textgreater{} to=\textless{}redacted\textgreater{} size=5203 , spam=no, virus=no tags=\PYGZob{}'virus': \PYGZob{}'F-Prot': False, 'ClamAV': False\PYGZcb{}, 'FprotPlugin.time': '0.0086', 'spam': \PYGZob{}\PYGZcb{}, 'incomingport': 10025, 'decisions': [('F-Prot Plugin', 0), ('ClamavPlugin', 0)], 'ClamavPlugin.time': '0.0092'\PYGZcb{} : Running Plugin SAPlugin
*******
[102]: waiting for task
*******
[103]: waiting for task
*******
[104]: waiting for task
*******
[105]: waiting for task
*******
[106]: Suspect b47e2ebf00e3f0d83dc1c7f64dad69e8: from=\textless{}redacted\textgreater{} to=\textless{}redacted\textgreater{} size=29442 , spam=no, virus=no tags=\PYGZob{}'virus': \PYGZob{}'F-Prot': False, 'ClamAV': False\PYGZcb{}, 'FprotPlugin.time': '0.0240', 'spam': \PYGZob{}\PYGZcb{}, 'incomingport': 10025, 'decisions': [('F-Prot Plugin', 0), ('ClamavPlugin', 0)], 'ClamavPlugin.time': '0.0240'\PYGZcb{} : Running Plugin SAPlugin
*******
[107]: waiting for task
\end{Verbatim}

run fuglu\_control without arguments to get a list of all supported commands.


\subsection{Logs}
\label{operation-index:logs}
Fuglu writes to /var/log/fuglu/fuglu.log by default. A summary of each analyzed message is stored in that file immediately after it has been analyzed..

Fuglu uses the standard python logging framework. This allows you to configure logging for each plugin individually (verbosity, own logfile, ...)

Full documentation on the python logging configuration: \href{http://docs.python.org/library/logging.html\#configuring-logging}{http://docs.python.org/library/logging.html\#configuring-logging}

Logging is configured in \code{/etc/fuglu/logging.conf}

in standard configuration, fuglu logs only INFO messages. Let's say you wanted to debug the spamassassin plugin. So you'd check if there is a section dealing with spamassassin and you'd find this:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{n}{logger\PYGZus{}saplugin}\PYG{p}{]}
\PYG{n}{level}\PYG{o}{=}\PYG{n}{INFO}
\PYG{n}{handlers}\PYG{o}{=}\PYG{n}{logfile}
\PYG{n}{propagate}\PYG{o}{=}\PYG{l+m+mi}{0}
\PYG{n}{qualname}\PYG{o}{=}\PYG{n}{fuglu}\PYG{o}{.}\PYG{n}{plugin}\PYG{o}{.}\PYG{n}{SAPlugin}
\end{Verbatim}

You would change \code{level=INFO} to \code{level=DEBUG}. Also you need to activate this special configuration for spamassassin by adding it to the loggers section at the top of the file:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{n}{loggers}\PYG{p}{]}
\PYG{n}{keys}\PYG{o}{=}\PYG{n}{root}\PYG{p}{,}\PYG{n}{saplugin}
\end{Verbatim}

after reloading fuglu, the spamassassin plugin should be very verbose:

\begin{Verbatim}[commandchars=\\\{\}]
2009-04-08 17:11:07,693 fuglu.plugin.SAPlugin: DEBUG Contacting spamd localhost (Try 1 of 5)
2009-04-08 17:11:07,701 fuglu.plugin.SAPlugin: DEBUG Sent 4065 bytes to spamd
2009-04-08 17:11:10,033 fuglu.plugin.SAPlugin: DEBUG SPAMD/1.1 0 EX\_OK

2009-04-08 17:11:10,034 fuglu.plugin.SAPlugin: DEBUG Got 4778 message bytes from back from spamd
2009-04-08 17:11:10,047 fuglu.plugin.SAPlugin: DEBUG Spamscore: 2.2
2009-04-08 17:11:10,047 fuglu.plugin.SAPlugin: DEBUG Message is not spam
\end{Verbatim}

there should be logger sections configured for most tasks / plugins, if not, do not hesitate to open a bug on this.

== Qualnames for new loggers ==
Plugins usually use fuglu.plugin.\textless{}classname\textgreater{}

fuglu internal qualnames:
\begin{itemize}
\item {} 
\code{fuglu.SessionHandler} - What plugins are being run, what are the results, ...

\item {} 
\code{fuglu.smtp.incoming} - Incoming smtp connections

\item {} 
\code{fuglu.smtp.incoming.\textless{}portnumber\textgreater{}} - Incoming smtp sessions on port \textless{}portnumber\textgreater{}

\item {} 
\code{fuglu.smtpsession} - information on the incoming smtp transaction

\item {} 
\code{fuglu.threadpool} - information when threads are created / destroyed

\item {} 
\code{fuglu.headerfilter} - debug info on parsing/applying the special header filter config files

\end{itemize}


\subsection{MRTG}
\label{operation-index:mrtg}
Fuglu can be configured to peridically write status files readable by mrtg. To do this, you only have to create a new directory (eg \code{/usr/local/fuglu/mrtg}) and set this in \code{fuglu.conf}:

\begin{Verbatim}[commandchars=\\\{\}]
\#Statistics
mrtgdir=/usr/local/fuglu/mrtg
\end{Verbatim}

You'll need \emph{mrtg} and a \emph{webserver} for this to work... create a file called \code{/etc/fuglu/fuglu\_mrtg.cfg}  like this:

\begin{Verbatim}[commandchars=\\\{\}]
Interval: 5
WorkDir: /usr/local/fuglu/mrtg/output
WriteExpires: yes
Options[\_]: growright,nopercent
LogFormat: rrdtool

\#---------------------------------------------------------------
Target[inout]: {}`cat /usr/local/fuglu/mrtg/inout{}`
PageTop[inout]: \textless{}H1\textgreater{}Messages in/out\textless{}/H1\textgreater{}
Options[inout]: growright,nopercent
Title[inout]: Messages in/out
ShortLegend[inout]: msgs/s
YLegend[inout]: messages
LegendI[inout]: in
Legend1[inout]: Incoming Messages
Legend2[inout]: Messages re-injected
LegendO[inout]: re-inject
MaxBytes[inout]: 60000000

Target[hamspam]: {}`cat /usr/local/fuglu/mrtg/hamspam{}`
Options[hamspam]: growright,nopercent
Title[hamspam]: Ham / Spam
PageTop[hamspam]: \textless{}H1\textgreater{}Ham / Spam\textless{}/H1\textgreater{}
YLegend[hamspam]: messages/second
ShortLegend[hamspam]: msgs/s
LegendI[hamspam]: ham
Legend1[hamspam]: Clean Messages (ham)
LegendO[hamspam]: spam
Legend2[hamspam]: Messages detected as spam
MaxBytes[hamspam]: 600000
AbsMax[hamspam]: 600000

Target[scantime]: {}`cat /usr/local/fuglu/mrtg/scantime{}`
Options[scantime]: growright,nopercent,gauge
Title[scantime]: Scan Time
PageTop[scantime]: \textless{}H1\textgreater{}Scan Time\textless{}/H1\textgreater{}
WithPeak[scantime]: ymwd
YLegend[scantime]: sec
ShortLegend[scantime]: sec
Legend1[scantime]: Time needed to analyze message
LegendI[scantime]: scantime
LegendO[scantime]:
Legend2[scantime]:
Legend3[scantime]: Peak Scantime
Legend4[scantime]:
MaxBytes[scantime]: 600000
AbsMax[scantime]: 600000


Target[threads]: {}`cat /usr/local/fuglu/mrtg/threads{}`
Options[threads]: growright,nopercent,gauge
Title[threads]: Threads
PageTop[threads]: \textless{}H1\textgreater{}Running Threads\textless{}/H1\textgreater{}
YLegend[threads]: threads
ShortLegend[threads]: threads
LegendO[threads]:
Legend1[threads]: Number of running threads
Legend2[threads]:
LegendI[threads]: threads
MaxBytes[threads]: 600000
AbsMax[threads]: 600000


Target[virus]: {}`cat /usr/local/fuglu/mrtg/virus{}`
Options[virus]: growright,nopercent
Title[virus]: virus
PageTop[virus]: \textless{}H1\textgreater{}Virus\textless{}/H1\textgreater{}
YLegend[virus]: virus
ShortLegend[virus]: virus
\#LegendO[virus]: virus
LegendI[virus]: virus
Legend1[virus]: Number of viri detected
MaxBytes[virus]: 600000
AbsMax[virus]: 600000
\end{Verbatim}

make sure, the path in WorkDir exists.

then create a script \code{/usr/local/bin/fuglu\_mrtg.sh}

\begin{Verbatim}[commandchars=\\\{\}]
\#!/bin/sh
/usr/bin/env LANG=C /usr/bin/mrtg /etc/fuglu/fuglu\_mrtg.cfg
\end{Verbatim}

run \code{fuglu\_mrtg.sh} to check for errors.

if all went well, add it to your crontab:

\begin{Verbatim}[commandchars=\\\{\}]
*/5 * * * * /usr/local/bin/fuglu\_mrtg.sh \textgreater{}/dev/null 2\textgreater{}\&1
\end{Verbatim}

install mrtg-rrd.cgi (probably rename it to fuglu.cgi ), and configure the path to fuglu\_mrtg.cfg correctly:

\begin{Verbatim}[commandchars=\\\{\}]
\# EDIT THIS to reflect all your MRTG config files
BEGIN \PYGZob{} @config\_files = qw(/etc/fuglu/fuglu\_mrtg.cfg); \PYGZcb{}
\end{Verbatim}

after pointing your browser to \code{http://yourfuglubox.example.com/cgi-bin/fuglu.cgi} you should see nice graphs.


\section{Troubleshooting \& Debugging}
\label{operation-index:troubleshooting-debugging}

\subsection{Fuglu doesn't even start}
\label{operation-index:fuglu-doesn-t-even-start}\begin{itemize}
\item {} 
run \code{fuglu -{-}lint} as root. are there any errors?

\item {} 
did you create /etc/fuglu/logging.conf (by renaming the logging.conf.dist file) ?

\item {} 
check if the log directory (/var/log/fuglu/ by default) exists an is writable by the user running fuglu

\item {} 
check for errors in /var/log/fuglu.log

\item {} 
run fuglu fuglu in foreground by setting \code{daemonize=0} in fuglu.conf

\end{itemize}


\subsection{Debug Trace a single message}
\label{operation-index:debug-trace-a-single-message}
Fuglu runs but you want to know what exactly would happen to a single email message?

Make sure message debugging is enabled (it is by default, but if you screwed up your config...) :
\begin{itemize}
\item {} 
\code{prependers=} should start with \code{debug} to make sure the debugger plugin is loaded

\item {} 
\code{incomingport} option should contian port 10888 (eg. incomingport=10025,10099,10888 ) , so fuglu listens on the debugging port

\item {} 
in the {[}debug{]} section, set debugport=10888 and debugfile=/tmp/fuglu\_debug.log , so the debugger plugin knows what port to treat as debug port and where to store debug information

\item {} 
\code{nobounce} should be set to True, so debugged messages can not be bounced

\item {} 
\code{noreinject} shoud be set to True, so debugged messages are not re-injected to postfix for further processing

\item {} 
\code{noappender} should be set to True, so appenders are not run for debugged messages

\end{itemize}

Save the message on the server (rfc822 format), and run

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{fuglu\PYGZus{}debug} \PYG{o}{/}\PYG{n}{path}\PYG{o}{/}\PYG{n}{to}\PYG{o}{/}\PYG{n}{message}\PYG{o}{.}\PYG{n}{eml}
\end{Verbatim}

you may add envelope sender and recipient if these are relevant for your test, eg:

\begin{Verbatim}[commandchars=\\\{\}]
fuglu\_debug /path/to/message.eml sender@example.org recipient@example.net
\end{Verbatim}

then check \code{/tmp/fuglu\_debug.log}


\subsection{Debug the fuglu core}
\label{operation-index:debug-the-fuglu-core}
If you are a python developer and would like to inspect fuglu at run-time, add the argument \code{-{-}console} when starting fuglu.
You will then get an interactive python console where all plugins etc are available from the `mc' (MainController) object


\chapter{Plugins}
\label{plugins-index::doc}\label{plugins-index:plugins}

\section{Overview}
\label{plugins-index:overview}
The fuglu core does nothing except receiving mails from postfix and sending them back. All functionality
is written in plugins which can be enabled or disabled at will. Fuglu provides plugins for the most common
mail filtering requirements, but if some functionality is missing, it is easy to add new plugins without knowing
all of fuglu's internals.


\section{Types of plugins}
\label{plugins-index:types-of-plugins}

\subsection{Scanner Plugins}
\label{plugins-index:scanner-plugins}
Scanner plugins are the most important type of plugins. They do the actual mail content filtering.
Plugins are run in the order specified in the \code{plugins=} configuration option. Each plugin returns an action
for the message:
\begin{itemize}
\item {} 
\textbf{DUNNO}  : This plugin decides not to take any final action, continue with the next plugin (this is the most common case)

\item {} 
\textbf{ACCEPT} : Whitelist this message, don't run any remaining plugins

\item {} 
\textbf{DELETE} : Silently delete this message (The sender will think it has been delivered)

\item {} 
\textbf{DEFER}  : Temporary Reject (4xx error), used for error conditions in after-queue mode or things like greylisting in before-queue mode

\item {} 
\textbf{REJECT} : Reject this message, should only be used in before-queue mode (in after-queue mode this would produce a bounce / backscatter)

\end{itemize}

If one of the plugins returns something other than \emph{DUNNO}, all remaining scanner plugins are skipped.
If all plugins return DUNNO, the message is accepted and re-injected to postfix.


\subsection{Prepender Plugins}
\label{plugins-index:prepender-plugins}
Prepender plugins run before the scanner plugins and have the ability to alter the
list of scanner plugins to be run. This can be used for example to have different plugins
run for incoming or outgoing mails or to skip whitelisted messages.


\subsection{Appender Plugins}
\label{plugins-index:appender-plugins}
Appender plugins are run after the scanner plugins when the message has alr
eady been re-injected into postfix
(or rejected or deleted or...) so they don't increase your scanning time . They are mostly used for statistical tasks, updating counters in database etc.


\section{Plugin configuration}
\label{plugins-index:plugin-configuration}
Each plugin has its own configuration section in \code{/etc/fuglu/fuglu.conf} or any \code{*.conf} in \code{/etc/fuglu/conf.d}. The section is usually
named like the plugin itself.

For example, the Spamassassin Plugin's Name is \code{SAplugin}, so it would search for a \code{{[}SAPlugin{]}} config section.


\subsection{Suspect Filters}
\label{plugins-index:suspect-filters}
SuspectFilter are special rule files used by many fuglu plugins. Often they define actions a plugin should take based on a suspects header or tag.

The format is : \textless{}headername\textgreater{} \textless{}regex\textgreater{} \textless{}optional argument\textgreater{}
\begin{description}
\item[{\textless{}headername\textgreater{} can be any of...}] \leavevmode\begin{itemize}
\item {} 
a email header name, eg \code{Received}, \code{To}, \code{From}, \code{Subject} ... also supports `*' as wildcard character

\item {} 
\code{mime:{}`{}`{}`{}`\textless{}headeraneme\textgreater{}} to get mime Headers in the message payload  eg: \code{mime:Content-Disposition}

\item {} 
one of fuglus builtin names to get envelope data:

\end{itemize}
\begin{itemize}
\item {} 
\code{envelope\_from}  (the envelope from address)

\item {} 
\code{from\_domain} (domain part of envelope\_from)

\item {} 
\code{envelope\_to} (envelope to address)

\item {} 
\code{to\_domain} (domain part of envelope\_to)

\end{itemize}
\begin{itemize}
\item {} 
a \code{message Tag} prepended by the @ symbol, eg. \code{@incomingport}

\item {} 
\code{body:raw}` to match the the decoded message body (only applies to text/* partsl)

\item {} 
\code{body:stripped} or just \code{body} to match the the  message body (only applies to text/* parts), with stripped tags and newlines replaced with space (similar to SpamAssassin body rules)

\item {} 
\code{body:full} to match the full body

\end{itemize}

\end{description}

\code{\textless{}regex\textgreater{}} is a standard python regular expression applied to \textless{}header\textgreater{}. if the regex is not enclosed by forward slashes, be sure not to include any whitespace in the regex, it must be one continous string. To match whitespace, use \code{\textbackslash{}s}. all regexes that are not enclosed in forward slashes are automatically \code{case insensitive} and support multiple lines (re.DOTALL is enabled, so the newline character is matched by a dot). with slashes, the regex flags can be defined manually, eg.

\begin{Verbatim}[commandchars=\\\{\}]
Subject /hello world/i match hello world, case insensitive
\end{Verbatim}

\code{\textless{}optional argument\textgreater{}} depends on the plugin that reads this header filter file, some don't need arguments at all. Please refer to the plugin documentation.

Filter files are automatically reloaded if you change anything, so you don't need to restart fuglu.

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\#normal header test
Subject hello   Hello in the subject!
MIME-Version \textasciicircum{}1\PYGZbs{}.0\$ Mime Version is 1.0

\#builtin special fields
to\_domain       (\PYGZbs{}.)?fuglu.org\$ Sent to fuglu.org or any subdomain
envelope\_from \textasciicircum{}sender@example.com\$

\#match a tag from a previous plugin
@SAPlugin.report MISSING\_HEADER

\#wildcard
X-Spam-* .*     a X-Spam-\textless{}something\textgreater{} header exists

\#decoded body text parts
body    Viagra

\#full body
body:full \textasciicircum{}--SPAMMY-MIME-BOUNDARY

\#mime-headers
mime:Content-Type \textasciicircum{}application\PYGZbs{}/x-msdos-program\$
\end{Verbatim}


\subsection{Template Variables}
\label{plugins-index:template-variables}
Some plugins allow you to create templates (errormessages in bounces, Reject reasons, ...). Here is a list of commonly used template variables that should be available in those templates. Plugins may not support all those variables and can add more variables not listed here. If unsure, check the plugin documentation.
\begin{itemize}
\item {} 
\code{\$\{from\_address\}} : Envelope Sender Address

\item {} 
\code{\$\{to\_address\}}   : Envelope Recipient Address

\item {} 
\code{\$\{from\_domain\}}  : Envelope Sender Domain

\item {} 
\code{\$\{to\_domain\}}    : Envelope Recipient Domain

\item {} 
\code{\$\{timestamp\}}    : Unix Timestamp when the message was received

\item {} 
\code{\$\{subject\}}      : Message subject

\item {} 
\code{\$\{date\}}         : Current date

\item {} 
\code{\$\{time\}}         : Current time

\item {} 
\code{\$\{blockinfo\}}    : Reason why this message was blocked (available in the attachment plugin)

\end{itemize}


\section{Plugins included in Fuglu}
\label{plugins-index:plugins-included-in-fuglu}

\subsection{SpamAssassin}
\label{plugins-index:spamassassin}
Plugin: fuglu.plugins.sa.SAPlugin

This plugin passes suspects to a spamassassin daemon.

Prerequisites: SPAMD must be installed and running (not necessarily on the same box as fuglu)

Notes for developers:

if forwardoriginal=False, the message source will be completely replaced with the answer from spamd.

Tags:
\begin{itemize}
\item {} 
reads \code{SAPlugin.skip}, (boolean) skips scanning if this is True

\item {} 
reads \code{SAPlugin.tempheader}, (text) prepends this text to the scanned message (use this to pass temporary headers to spamassassin which should not be visible in the final message)

\item {} 
sets \code{spam{[}'spamassassin'{]}} (boolean)

\item {} 
sets \code{SAPlugin.spamscore} (float) if possible

\item {} 
sets \code{SAPlugin.time} (float)

\item {} 
sets \code{SAPlugin.skipreason} (string) if the message was not scanned (fuglu \textgreater{}0.5.0)

\end{itemize}


\subsubsection{Configuration}
\label{plugins-index:configuration}
\begin{Verbatim}[commandchars=\\\{\}]
[SAPlugin]
\#how often should fuglu retry the connection before giving up
retries=3

\#action if there is a problem (DUNNO, DEFER)
problemaction=DEFER

\#reject message template if running in pre-queue mode
rejectmessage=message identified as spam

\#forward the original message or replace the content as returned by spamassassin
\#if this is set to True/1/Yes , no spamassassin headers will be visible in the final message.
\#"original" in this case means "as passed to spamassassin", eg. if 'scanoriginal' is set to 0 above this will forward the
\#message as retreived from previous plugins
forwardoriginal=0

\#consult spamassassins(or any other) sql blacklist for messages that are too big for spam checks
\#requires the sql extension to be enabled
check\_sql\_blacklist=0

\#sqlalchemy db connect string
sql\_blacklist\_dbconnectstring=mysql:///localhost/spamassassin

\#SQL query to get the blacklist entries for a suspect
\#you may use template variables: \$\PYGZob{}from\_address\PYGZcb{} \$\PYGZob{}from\_domain\PYGZcb{} \$\PYGZob{}to\_address\PYGZcb{} \$\PYGZob{}to\_domain\PYGZcb{}
sql\_blacklist\_sql=SELECT value FROM userpref WHERE prefid='blacklist\_from' AND username in ('@GLOBAL',concat('\%',\$\PYGZob{}to\_domain\PYGZcb{}),\$\PYGZob{}to\_address\PYGZcb{})

\#maximum size in bytes. larger messages will be skipped
maxsize=256000

\#what header does sa set to indicate the spam status
spamheader=X-Spam-Status

\#hostname where spamd runs
host=localhost

\#what should we do with high spam (spam score above highspamlevel)
highspamaction=DEFAULTHIGHSPAMACTION

\#how long should we wait for an answer from sa
timeout=30

\#spamscore threshold to mark a message as high spam
highspamlevel=15

\#enable SA user configuration
peruserconfig=1

\#tcp port number
port=783

\#should we scan the original message as retreived from postfix or scan the current state
\#in fuglu (which might have been altered by previous plugins)
\#only set this to disabled if you have a custom plugin that adds special headers to the message that will be
\#used in spamassassin rules
scanoriginal=1

\#what should we do with low spam (eg. detected as spam, but score not over highspamlevel)
lowspamaction=DEFAULTLOWSPAMACTION
\end{Verbatim}


\subsection{Clam AV}
\label{plugins-index:clam-av}
Plugin: fuglu.plugins.clamav.ClamavPlugin

This plugin passes suspects to a clam daemon.

Actions: This plugin will delete infected messages. If clamd is not reachable or times out, messages can be DEFERRED.

Prerequisites: You must have clamd installed (for performance reasons I recommend it to be on the same box, but this is not absoluely necessary)

Notes for developers:

Tags:
\begin{itemize}
\item {} 
sets \code{virus{[}'ClamAV'{]}} (boolean)

\item {} 
sets \code{ClamavPlugin.virus} (list of strings) - virus names found in message

\item {} 
sets \code{ClamavPlugin.time} (float)

\end{itemize}


\subsubsection{Configuration}
\label{plugins-index:id1}
\begin{Verbatim}[commandchars=\\\{\}]
[ClamavPlugin]
\#how often should fuglu retry the connection before giving up
retries=3

\#hostname where clamd runs
host=localhost

\#reject message template if running in pre-queue mode and virusaction=REJECT
rejectmessage=threat detected: \$\PYGZob{}virusname\PYGZcb{}

\#socket timeout
timeout=30

\#action if there is a problem (DUNNO, DEFER)
problemaction=DEFER

\#maximum message size, larger messages will not be scanned.
\#should match the 'StreamMaxLength' config option in clamd.conf
maxsize=22000000

\#tcp port number or path to clamd.sock for unix domain sockets
\#example /var/lib/clamav/clamd.sock or on ubuntu: /var/run/clamav/clamd.ctl
port=3310

\#action if infection is detected (DUNNO, REJECT, DELETE)
virusaction=DEFAULTVIRUSACTION
\end{Verbatim}


\subsection{Attachment Blocker}
\label{plugins-index:attachment-blocker}
Plugin: fuglu.plugins.attachment.FiletypePlugin

This plugin checks message attachments. You can configure what filetypes or filenames are allowed to pass through fuglu. If a attachment is not allowed, the message is deleted and the sender receives a bounce error message. The plugin uses the `'`file'`' library to identify attachments, so even if a smart sender renames his executable to .txt, fuglu will detect it.

Attachment rules can be defined globally, per domain or per user.

Actions: This plugin will delete messages if they contain blocked attachments.

Prerequisites: You must have the python \code{file} or \code{magic} module installed

The attachment configuration files are in \code{/etc/fuglu/rules}. You whould have two default files there: \code{default-filenames.conf} which defines what filenames are allowed and \code{default-filetypes.conf} which defines what content types a attachment may have.

For domain rules, create a new file \code{\textless{}domainname\textgreater{}-filenames.conf} / \code{\textless{}domainname\textgreater{}-filetypes.conf} , eg. \code{fuglu.org-filenames.conf} / \code{fuglu.org-filetypes.conf}

For individual user rules, create a new file \code{\textless{}useremail\textgreater{}-filenames.conf} / \code{\textless{}useremail\textgreater{}-filetypes.conf}, eg. \code{oli@fuglu.org-filenames.conf} / \code{oli@fuglu.org-filetypes.conf}

The format of those files is as follows: Each line should have three parts, seperated by tabs (or any whitespace):
\textless{}action\textgreater{}    \textless{}regular expression\textgreater{}   \textless{}description or error message\textgreater{}
\begin{description}
\item[{\textless{}action\textgreater{} can be one of:}] \leavevmode\begin{itemize}
\item {} 
allow : this file is ok, don't do further checks (you might use it for safe content types like text). Do not blindly create `allow' rules. It's safer to make no rule at all, if no other rules hit, the file will be accepted

\item {} 
deny : delete this message and send the error message/description back to the sender

\item {} 
delete : silently delete the message, no error is sent back, and `blockaction' is ignored

\end{itemize}

\end{description}

\textless{}regular expression\textgreater{} is a standard python regex. in x-filenames.conf this will be applied to the attachment name . in x-filetypes.conf this will be applied to the mime type of the file as well as the file type returned by the \code{file} command.

example of default-filetypes.conf:

\begin{Verbatim}[commandchars=\\\{\}]
allow    text        -
allow    script    -
allow    archive        -
allow    postscript    -
deny    self-extract    No self-extracting archives
deny    executable    No programs allowed
deny    ELF        No programs allowed
deny    Registry    No Windows Registry files allowed
\end{Verbatim}

small extract from default-filenames.conf:

\begin{Verbatim}[commandchars=\\\{\}]
deny    \PYGZbs{}.ico\$            Windows icon file security vulnerability
deny    \PYGZbs{}.ani\$            Windows animated cursor file security vulnerability
deny    \PYGZbs{}.cur\$            Windows cursor file security vulnerability
deny    \PYGZbs{}.hlp\$            Windows help file security vulnerability

allow    \PYGZbs{}.jpg\$            -
allow    \PYGZbs{}.gif\$            -
\end{Verbatim}

Note: The files will be reloaded automatically after a few seconds (you do not need to kill -HUP / restart fuglu)

The bounce template (eg /etc/fuglu/templates/blockedfile.tmpl) should look like this:

\begin{Verbatim}[commandchars=\\\{\}]
To: \$\PYGZob{}from\_address\PYGZcb{}
Subject: Blocked attachment

Your message to \$\PYGZob{}to\_address\PYGZcb{} contains a blocked attachment and has been deleted.

\$\PYGZob{}blockinfo\PYGZcb{}

You may add this file to a zip archive (or similar) and send it again.
\end{Verbatim}

eg. define headers for your message at the beginning, followed by a blank line. Then append the message body.

\code{\$\{blockinfo\}} will be replaced with the text you specified in the third column of the rule that blocked this message.

See (TODO: link to template vars chapter) for commonly available template variables in Fuglu.


\subsubsection{Configuration}
\label{plugins-index:id2}
\begin{Verbatim}[commandchars=\\\{\}]
[FiletypePlugin]
\#inform the sender about blocked attachments
sendbounce=1

\#Mail template for the bounce to inform sender about blocked attachment
template\_blockedfile=/etc/fuglu/templates/blockedfile.tmpl

\#what should the plugin do when a blocked attachment is detected
\#REJECT : reject the message (recommended in pre-queue mode)
\#DELETE : discard messages
\#DUNNO  : mark as blocked but continue anyway (eg. if you have a later quarantine plugin)
blockaction=DELETE

\#sqlalchemy connectstring to load rules from a database and use files only as fallback. requires SQL extension to be enabled
dbconnectstring=

\#sql query to load rules from a db. \#:scope will be replaced by the recipient address first, then by the recipient domain
\#:check will be replaced by either 'filename' to get filename rules or 'contenttype' to get content type rules
query=SELECT action,regex,description FROM attachmentrules WHERE scope=:scope AND checktype=:checktype ORDER BY prio

\#directory that contains attachment rules
rulesdir=/etc/fuglu/rules
\end{Verbatim}


\subsection{Archive}
\label{plugins-index:archive}
Plugin: fuglu.plugins.archive.ArchivePlugin

This plugins stores a copy of the message if it matches certain criteria (Suspect Filter).
You can use this if you want message archives for your domains or to debug problems occuring only for certain recipients.

Examples for the archive.regex filter file:

archive messages to domain `'test.com'`:

\code{to\_domain test\textbackslash{}.com}

archive messages from \href{mailto:oli@fuglu.org}{oli@fuglu.org}:

\code{envelope\_from oli@fuglu\textbackslash{}.org}

you can also append ``yes'' and ``no'' to the rules to create a more advanced configuration. Lets say we want to archive all messages to \href{mailto:sales@fuglu.org}{sales@fuglu.org} and all regular messages \href{mailto:support@fuglu.org}{support@fuglu.org} except the ones created by automated scripts like logwatch or daily backup messages etc.

envelope\_to \href{mailto:sales@fuglu.org}{sales@fuglu.org} yes
envelope\_from logwatch@.*fuglu.org   no
from \href{mailto:backups@fuglu.org}{backups@fuglu.org} no
envelope\_to \href{mailto:support@fuglu.org}{support@fuglu.org}      yes


\subsubsection{Configuration}
\label{plugins-index:id3}
\begin{Verbatim}[commandchars=\\\{\}]
[ArchivePlugin]
\#change owner of saved messages (username or numeric id) - this only works if fuglu is running as root (which is NOT recommended)
chown=

\#Archiving SuspectFilter File
archiverules=/etc/fuglu/archive.regex

\#filename template for the archived messages
filenametemplate=\$\PYGZob{}id\PYGZcb{}.eml

\#subdirectory within archivedir
subdirtemplate=\$\PYGZob{}to\_domain\PYGZcb{}

\#if true/1/yes: store original message
\#if false/0/no: store message probably altered by previous plugins, eg with spamassassin headers
storeoriginal=1

\#storage for archived messages
archivedir=/tmp

\#set file permissions of saved messages
chmod=

\#change group of saved messages (groupname or numeric id) - the user running fuglu must be a member of the target group for this to work
chgrp=
\end{Verbatim}


\subsection{Vacation}
\label{plugins-index:vacation}
Plugin: fuglu.plugins.vacation.VacationPlugin

Sends out-of-office reply messages. Configuration is got from a sql database. Replies are only sent once per day per sender. The plugin will not reply to any `automated' messages (Mailingslists, Spams, Bounces etc)

Requires: SQLAlechemy Extension
\begin{description}
\item[{Required DB Tables:}] \leavevmode\begin{itemize}
\item {} 
vacation (fuglu reads this table only, must be filled from elsewhere)
\begin{itemize}
\item {} 
id int : id of this vacation

\item {} 
created timestamp :  creation timestamp

\item {} 
enabled boolean (eg. tinyint) : if disabled, no vacation reply will be sent

\item {} 
start timestamp: replies will only be sent after this point in time

\item {} 
end timestamp: replies will only be sent before this point in time

\item {} 
awayuser varchar: the email address of the user that is on vacation

\item {} 
subject: subject of the vacation message

\item {} 
body : body of the vacation message

\item {} 
ignoresender: whitespace delimited list of domains or email addresses that should not receive vacation replies

\end{itemize}

\item {} 
vacationreply (this table is filled by fuglu)
\begin{itemize}
\item {} 
id int: id of the reply

\item {} 
vacation\_id : id of the vacation

\item {} 
sent timestamp: timestamp when the reply was sent

\item {} 
recipient: recipient to whom the reply was sent

\end{itemize}

\end{itemize}

\end{description}

SQL Example for mysql:

\begin{Verbatim}[commandchars=\\\{\}]
CREATE TABLE {}`vacation{}` (
  {}`id{}` int(11) NOT NULL auto\_increment,
  {}`created{}` timestamp NOT NULL default now(),
  {}`start{}` timestamp NOT NULL,
  {}`end{}` timestamp NOT NULL ,
  {}`enabled{}` tinyint(1) NOT NULL default 1,
  {}`awayuser{}` varchar(255) NOT NULL,
  {}`subject{}` varchar(255) NOT NULL,
  {}`body{}` text NOT NULL,
  {}`ignoresender{}` text NOT NULL,
  PRIMARY KEY  ({}`id{}`),
  UNIQUE({}`awayuser{}`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 ;


CREATE  TABLE {}`vacationreply{}` (
  {}`id{}` int(11) NOT NULL auto\_increment,
  {}`recipient{}` varchar(255) NOT NULL,
  {}`vacation\_id{}` int(11) NOT NULL,
     {}`sent{}` timestamp not null default now(),
  PRIMARY KEY  ({}`id{}`),
  KEY {}`vacation\_id{}` ({}`vacation\_id{}`),
  CONSTRAINT {}`vacation\_ibfk\_1{}` FOREIGN KEY ({}`vacation\_id{}`) REFERENCES {}`vacation{}` ({}`id{}`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
\end{Verbatim}


\subsubsection{Configuration}
\label{plugins-index:id4}
\begin{Verbatim}[commandchars=\\\{\}]
[VacationPlugin]
\#sqlalchemy connectstring to load vacations
dbconnectstring=
\end{Verbatim}


\subsection{Sophos}
\label{plugins-index:sophos}
Plugin: fuglu.plugins.sssp.SSSPPlugin
\begin{quote}

This plugin scans the suspect using the sophos SSSP protocol.
\end{quote}

Prerequisites: Requires a running sophos daemon with dynamic interface (SAVDI)


\subsubsection{Configuration}
\label{plugins-index:id5}
\begin{Verbatim}[commandchars=\\\{\}]
[SSSPPlugin]
\#how often should fuglu retry the connection before giving up
retries=3

\#hostname where the SSSP server runs
host=localhost

\#reject message template if running in pre-queue mode and virusaction=REJECT
rejectmessage=threat detected: \$\PYGZob{}virusname\PYGZcb{}

\#socket timeout
timeout=30

\#action if there is a problem (DUNNO, DEFER)
problemaction=DEFER

\#maximum message size, larger messages will not be scanned.
maxsize=22000000

\#tcp port or path to unix socket
port=4010

\#action if infection is detected (DUNNO, REJECT, DELETE)
virusaction=DEFAULTVIRUSACTION
\end{Verbatim}


\subsection{F-Prot AV}
\label{plugins-index:f-prot-av}
Plugin: fuglu.plugins.fprot.FprotPlugin
\begin{quote}

This plugin passes suspects to a f-prot scan daemon
\end{quote}

Prerequisites: f-protd must be installed and running, not necessarily on the same box as fuglu though.

Notes for developers:

Tags:
\begin{itemize}
\item {} 
sets \code{virus{[}'F-Prot'{]}} (boolean)

\item {} 
sets \code{FprotPlugin.virus} (list of strings) - virus names found in message

\item {} 
sets \code{FprotPlugin.time} (float)

\end{itemize}


\subsubsection{Configuration}
\label{plugins-index:id6}
\begin{Verbatim}[commandchars=\\\{\}]
[FprotPlugin]
\#maximum retries on failed connections
retries=3

\#hostname where fpscand runs
host=localhost

\#reject message template if running in pre-queue mode and virusaction=REJECT
rejectmessage=threat detected: \$\PYGZob{}virusname\PYGZcb{}

\#if fpscand runs on a different host than fuglu, set this to 1 to send the message over the network instead of just the filename
networkmode=0

\#network timeout
timeout=30

\#plugin action if scan fails
problemaction=DEFER

\#maximum message size to scan
maxsize=10485000

\#fpscand port
port=10200

\#plugin action if threat is detected
virusaction=DEFAULTVIRUSACTION
\end{Verbatim}


\subsection{ICAP AV}
\label{plugins-index:icap-av}
Plugin: fuglu.plugins.icap.ICAPPlugin

ICAP Antivirus Plugin
This plugin allows Antivirus Scanning over the ICAP Protocol (\href{http://tools.ietf.org/html/rfc3507}{http://tools.ietf.org/html/rfc3507} )
supported by some AV Scanners like Symantec and Sophos. For sophos, however, it is recommended to use the native SSSP Protocol.

Prerequisites: requires an ICAP capable antivirus engine somewhere in your network


\subsubsection{Configuration}
\label{plugins-index:id7}
\begin{Verbatim}[commandchars=\\\{\}]
[ICAPPlugin]
\#how often should fuglu retry the connection before giving up
retries=3

\#hostname where the ICAP server runs
host=localhost

\#reject message template if running in pre-queue mode and virusaction=REJECT
rejectmessage=threat detected: \$\PYGZob{}virusname\PYGZcb{}

\#ICAP Av scan service, usually AVSCAN (sophos, symantec)
service=AVSCAN

\#socket timeout
timeout=10

\#action if there is a problem (DUNNO, DEFER)
problemaction=DEFER

\#name of the virus engine behind the icap service. used to inform other plugins. can be anything like 'sophos', 'symantec', ...
enginename=icap-generic

\#maximum message size, larger messages will not be scanned.
maxsize=22000000

\#tcp port or path to unix socket
port=1344

\#action if infection is detected (DUNNO, REJECT, DELETE)
virusaction=DEFAULTVIRUSACTION
\end{Verbatim}


\subsection{remove Headers}
\label{plugins-index:remove-headers}
Plugin: fuglu.plugins.headers.HeaderPlugin

Removes specified headers from message


\subsubsection{Configuration}
\label{plugins-index:id8}
\begin{Verbatim}[commandchars=\\\{\}]
[HeaderPlugin]
\#headers to remove from incoming messages, comma separated
removeheaders=
\end{Verbatim}


\subsection{Action Override}
\label{plugins-index:action-override}
Plugin: fuglu.plugins.actionoverride.ActionOverridePlugin
\begin{quote}

override Actions based on a Suspect Filter file. For example, delete all messages from a specific sender domain.
\end{quote}


\subsubsection{Configuration}
\label{plugins-index:id9}
\begin{Verbatim}[commandchars=\\\{\}]
[ActionOverridePlugin]
\#Rules file
actionrules=/etc/fuglu/actionrules.regex
\end{Verbatim}


\subsection{ScriptFilter}
\label{plugins-index:scriptfilter}
Plugin: fuglu.plugins.script.ScriptFilter
\begin{quote}

This plugins executes scripts found in a specified directory.
\end{quote}

This can be used to quickly add a custom filter script without changing the fuglu configuration.

Filterscripts must be written in standard python but with the file ending \code{.fgf} (``fuglu filter'')

scripts are reloaded for every message executed in alphabetic order

The API is basically the same as for normal plugins within the \code{examine()} method, with a few special cases:

there is no `self' which means:
\begin{itemize}
\item {} 
access the configuration by using \code{config} directly (instead of \code{self.config})

\item {} 
use \code{debug('hello world')} instead of \code{self.logger.debug('hello world')}, this will also automatically write to the message debug channel

\end{itemize}

the script should not return anything, but change the available variables \code{action} and \code{message} instead
(\code{DUNNO}, \code{REJECT}, \code{DEFER}, \code{ACCEPT}, \code{DELETE} are already imported)

use \code{stop()} to exit the script

example script:
(put this in /etc/fuglu/scriptfilter/99\_demo.fgf for example)

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{}block all messages from evilsender.example.com}
\PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{suspect}\PYG{o}{.}\PYG{n}{from\PYGZus{}domain}\PYG{o}{==}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{evilsender.example.com}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}
    \PYG{n}{suspect}\PYG{o}{.}\PYG{n}{addheader}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x\PYGZhy{}fuglu\PYGZhy{}SenderDomain}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{suspect}\PYG{o}{.}\PYG{n}{from\PYGZus{}domain}\PYG{p}{,}\PYG{n}{immediate}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
    \PYG{n}{stop}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{debug}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{hello world}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{action}\PYG{o}{=}\PYG{n}{REJECT}
\PYG{n}{message}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{you shall not pass}\PYG{l+s}{\PYGZdq{}}
\end{Verbatim}


\subsubsection{Configuration}
\label{plugins-index:id10}
\begin{Verbatim}[commandchars=\\\{\}]
[ScriptFilter]
\#Dir that contains the scripts (*.fgf files)
scriptdir=/etc/fuglu/scriptfilter
\end{Verbatim}


\subsection{Plugin Skipper}
\label{plugins-index:plugin-skipper}
Plugin: fuglu.plugins.p\_skipper.PluginSkipper

Skips plugins based on standard filter file
This can be used for example to skip spam filters on outgoing messages.
eg. put this in /etc/fuglu/skipplugins.regex:

@incomingport    1099    SAPlugin


\subsubsection{Configuration}
\label{plugins-index:id11}
\begin{Verbatim}[commandchars=\\\{\}]
[PluginSkipper]
filterfile=/etc/fuglu/skipplugins.regex
\end{Verbatim}


\subsection{Debugger}
\label{plugins-index:debugger}
Plugin: fuglu.plugins.p\_debug.MessageDebugger

Message Debugger Plugin (Prepender).

This plugin enables the fuglu\_debug functionality. Make sure fuglu listens on the debug port configured here.


\subsubsection{Configuration}
\label{plugins-index:id12}
\begin{Verbatim}[commandchars=\\\{\}]
[MessageDebugger]
\#messages incoming on this port will be debugged to a logfile
\#Make sure the debugport is also set in the incomingport configuration option in the main section
debugport=10888

\#debug log output
debugfile=/tmp/fuglu\_debug.log

\#don't re-inject debugged messages back to postfix
noreinject=1

\#debugged message can not be bounced
nobounce=1

\#don't run appender plugins for debugged messages
noappender=1
\end{Verbatim}


\section{Writing your own plugins}
\label{plugins-index:writing-your-own-plugins}
Assuming you know python basics, writing plugins for fuglu is very easy. All you have to do is create a new class which extends from \code{ScannerPlugin}, override \code{\_\_str\_\_} to provide a nice human readable name and override \code{examine} to do the actual work of your plugins. \code{examine} should return one of the action codes above (DUNNO, DEFER, DELETE, ....). You probably only need stuff from \code{fuglu.shared}, so it's probably a good idea to get familiar with that module.

This is a quick example of how your plugin code skeleton would look like:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{fuglu.shared} \PYG{k+kn}{import} \PYG{n}{ScannerPlugin}\PYG{p}{,}\PYG{n}{DUNNO}
\PYG{k+kn}{import} \PYG{n+nn}{time}

\PYG{k}{class} \PYG{n+nc}{DemoPlugin}\PYG{p}{(}\PYG{n}{ScannerPlugin}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Copy this to make a new plugin\PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{k}{def} \PYG{n+nf}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{config}\PYG{p}{,}\PYG{n}{section}\PYG{o}{=}\PYG{n+nb+bp}{None}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{ScannerPlugin}\PYG{o}{.}\PYG{n}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{config}\PYG{p}{,}\PYG{n}{section}\PYG{p}{)}
        \PYG{c}{\PYGZsh{}config example}
        \PYG{c}{\PYGZsh{}self.requiredvars=\PYGZob{}}
        \PYG{c}{\PYGZsh{}    \PYGZsq{}maxsize\PYGZsq{}:\PYGZob{}}
        \PYG{c}{\PYGZsh{}        \PYGZsq{}default\PYGZsq{}:\PYGZsq{}1337\PYGZsq{},}
        \PYG{c}{\PYGZsh{}        \PYGZsq{}description\PYGZsq{}:\PYGZsq{}Maximum message size\PYGZsq{},}
        \PYG{c}{\PYGZsh{}    \PYGZcb{}}
        \PYG{c}{\PYGZsh{}\PYGZcb{}}

    \PYG{k}{def} \PYG{n+nf}{examine}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{suspect}\PYG{p}{)}\PYG{p}{:}
        \PYG{c}{\PYGZsh{}config Example}
        \PYG{c}{\PYGZsh{}maxsize=self.config.getint(self.section, \PYGZsq{}maxsize\PYGZsq{})}

        \PYG{c}{\PYGZsh{}debug example}
        \PYG{c}{\PYGZsh{}self.\PYGZus{}logger().debug(\PYGZsq{}hello world from StubPlugin\PYGZsq{})}

        \PYG{n}{starttime}\PYG{o}{=}\PYG{n}{time}\PYG{o}{.}\PYG{n}{time}\PYG{p}{(}\PYG{p}{)}


        \PYG{c}{\PYGZsh{}PUT PLUGIN CODE HERE}

        \PYG{c}{\PYGZsh{}For debugging, its good to know how long each plugin took}
        \PYG{n}{endtime}\PYG{o}{=}\PYG{n}{time}\PYG{o}{.}\PYG{n}{time}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{difftime}\PYG{o}{=}\PYG{n}{endtime}\PYG{o}{\PYGZhy{}}\PYG{n}{starttime}
        \PYG{n}{suspect}\PYG{o}{.}\PYG{n}{tags}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{DemoPlugin.time}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+si}{\PYGZpc{}.4f}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZpc{}}\PYG{n}{difftime}
        \PYG{k}{return} \PYG{n}{DUNNO}
\end{Verbatim}

First of all, you need a few imports. ScannerPlugin (so you can extend from it), and possible return values for your Plugin, DUNNO might be enough depending on what your plugin does.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{fuglu.shared} \PYG{k+kn}{import} \PYG{n}{ScannerPlugin}\PYG{p}{,}\PYG{n}{DUNNO}
\end{Verbatim}

in \_\_init\_\_ you only call BasicPlugins \_\_init\_\_  for now. This sets self.config and self.section on the object where you later can read config options (eg. self.config.get(self.section,'somevalue').  Do NOT load the plugin configuration here. \_\_init\_\_ is only called once when fuglu starts up. Always load plugin config in \code{examine}.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{config}\PYG{p}{,}\PYG{n}{section}\PYG{o}{=}\PYG{n+nb+bp}{None}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{ScannerPlugin}\PYG{o}{.}\PYG{n}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{config}\PYG{p}{,}\PYG{n}{section}\PYG{p}{)}
\end{Verbatim}

then code your \code{examine} method. You will have to work with the \code{suspect} (TODO: LINK HERE) object, which is a representation of the message being analyzed. The suspect has \code{tags} that are read and written by plugins. You can tag a message as virus, as spam, define your own tags, read tags from previous plugins...  it's probably a good idea to read FugluSuspect to get a list of things you can do with the suspect and FugluTags so see common tags that can have a influence on fuglu's behaviour.


\subsection{Common Tasks (``API'' FAQ)}
\label{plugins-index:common-tasks-api-faq}

\subsubsection{define configuration options for your plugin}
\label{plugins-index:define-configuration-options-for-your-plugin}
in order to make `lint' and `fuglu\_conf' work with your plugin it should tell the core what config options it expects. this is done by creating a dictionary named `requiredvars' in the plugins init:

Example:

\begin{Verbatim}[commandchars=\\\{\}]
def \_\_init\_\_(self,config,section=None):
        ScannerPlugin.\_\_init\_\_(self,config,section)
        self.requiredvars=\PYGZob{}
            'host':\PYGZob{}
                'default':'localhost',
                'description':'hostname',
            \PYGZcb{},

            'username':\PYGZob{}
                'default':'root',
            \PYGZcb{},

            'password':\PYGZob{}
                'default':{}`{}`,
                'confidential':True,
            \PYGZcb{},

       \PYGZcb{}
\end{Verbatim}

This would tell fuglu that your plugin has three config options: host, username and password.

The `dict of dicts' uses your config option name as key for the outer dict. The inner dict supports the following keys:
\begin{itemize}
\item {} 
\code{default} - Default value, used if the option is not specified in the config file

\item {} 
\code{section} - config section to check. by default fuglu assumes that the plugin reads its own config section. override this if your plugin requires a config option from a different plugin or from the main config

\item {} 
\code{confidential} - set this to True if fuglu\_conf should treat this option confidential and redact it in `fuglu\_conf -n' (passwords etc)

\item {} 
\code{validator} - function that should be called to validate if the configured value is valid. the function will receive the value as argument and must return True or False

\item {} 
\code{deprecated} - mark a config option as deprecated

\end{itemize}


\subsubsection{read the config}
\label{plugins-index:read-the-config}
Configs in fuglu are stored in \code{/etc/fuglu/fuglu.conf} (or any .conf file in /etc/fuglu/conf.d ) in ini-style format. Your plugin gets its own Section named like the Plugin Class.

example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{n}{DemoPlugin}\PYG{p}{]}
\PYG{n}{maxsize}\PYG{o}{=}\PYG{l+m+mi}{10382}
\end{Verbatim}

you can then read the config in your plugin with the usual methods from a python ConfigParser object ( \href{http://docs.python.org/library/configparser.html}{http://docs.python.org/library/configparser.html} )

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{maxsize}\PYG{o}{=}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{config}\PYG{o}{.}\PYG{n}{getint}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{section}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{maxsize}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

Important: always the configs in \code{examine} (and not in \code{init} !). reading the config in init breaks loading default values and prevents on-the-fly config reload


\subsubsection{get the message source}
\label{plugins-index:get-the-message-source}
use \code{suspect.getSource()} to get the message source. The maxbytes option allows you to get only a part of the source. Reading the whole source can slow down scanning of big messages.

from fuglu.shared import ScannerPlugin,DUNNO
import time
add headers
-----------

\code{suspect.addheader(headername,headervalue)}

by default, headers are added to the message shortly before it is re-injected into postfix.
add \code{immediate=True} to add the header immediately, so other plugins can see it.


\subsubsection{write to the log}
\label{plugins-index:write-to-the-log}
your plugin has a \_logger method that returns a standard python logger object, so you can use the info / debug / error / fatal methods.

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}logger}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{info}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{hello world from DemoPlugin}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}


\subsubsection{write debug info}
\label{plugins-index:write-debug-info}
to make the plugin write special debug info when \code{fuglu\_debug} is used, use:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{suspect}\PYG{o}{.}\PYG{n}{debug}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{debug info from DemoPlugin!}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}


\subsubsection{make plugin `--lint'-able}
\label{plugins-index:make-plugin-lint-able}
by default, \code{lint()} only validates the plugin's configuration settings from \code{self.requiredvars}. You can override \code{lint()} to do more stuff.
\begin{itemize}
\item {} 
use simple \code{print} in this method, no logging stuff.

\item {} 
if you override \code{lint()} you should run \code{self.checkConfig()} to test the configuration

\item {} 
\code{lint()} must return True or False

\end{itemize}

example of a plugin that would check if an imap account is available:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{lint}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{allok}\PYG{o}{=}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{checkConfig}\PYG{p}{(}\PYG{p}{)} \PYG{o+ow}{and} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{lint\PYGZus{}imap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{allok}

\PYG{k}{def} \PYG{n+nf}{lint\PYGZus{}imap}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{try}\PYG{p}{:}
        \PYG{n}{M}\PYG{o}{=}\PYG{n}{imaplib}\PYG{o}{.}\PYG{n}{IMAP4}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{config}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{section}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{host}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{(}\PYG{n+nb}{type}\PYG{p}{,}\PYG{n}{data}\PYG{p}{)}\PYG{o}{=}\PYG{n}{M}\PYG{o}{.}\PYG{n}{login}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{config}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{section}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{user}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{config}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{section}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{password}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
        \PYG{k}{if} \PYG{n+nb}{type}\PYG{o}{!=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{OK}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}
            \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Could not login to imap review account: }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{data}\PYG{p}{)}
            \PYG{k}{return} \PYG{n+nb+bp}{False}
        \PYG{k}{return} \PYG{n+nb+bp}{True}
    \PYG{k}{except} \PYG{n+ne}{Exception}\PYG{p}{,} \PYG{n}{e}\PYG{p}{:}
        \PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Could not login to imap host:}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{ \PYGZhy{} Error }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{config}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{StubPlugin}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{host}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}\PYG{n}{e}\PYG{p}{)}
    \PYG{k}{return} \PYG{n+nb+bp}{False}
\end{Verbatim}


\subsubsection{use the `SuspectFilter'}
\label{plugins-index:use-the-suspectfilter}
SuspectFilters are a common way for all plugins to perform an action based on conditions defined in a filterfile . These files are automatically re-loaded if changed.
\begin{itemize}
\item {} 
import SuspectFilter from fuglu.shared

\item {} 
define a config variable for your plugin which holds the name of the filter file (not strictly required, you could hardcode the path)

\item {} 
create a plugin property for the filter

\end{itemize}

\begin{Verbatim}[commandchars=\\\{\}]
from fuglu.shared import ScannerPlugin,SuspectFilter
[...]

class MyPlugin(ScannerPlugin):
    def \_\_init\_\_(self,config,section=None):
        ScannerPlugin.\_\_init\_\_(self,config,section)

        self.requiredvars=\PYGZob{}
            'myrulesfile':\PYGZob{}
                'default':'/etc/fuglu/mypluginrules.regex',
                'description':'Filter file for my plugin',
            \PYGZcb{},

           [...]
        \PYGZcb{}
        self.filter=None
\end{Verbatim}

in \code{examine} create the filter if necessary

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{filter}\PYG{o}{==}\PYG{n+nb+bp}{None}\PYG{p}{:}
    \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{filter}\PYG{o}{=}\PYG{n}{SuspectFilter}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{config}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{section}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{myrulesfile}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

run the filter in examine: \code{(match,arg)=self.filter.matches(suspect)}
\code{match} is a boolean, telling you if one of the rules matched
\emph{arg{}`} is an additional argument which have been appended to the filter rule in the config. lets say, the filter rule reads \code{to\_address example@fuglu.org hello world!}, you would get match=True and arg='Hello world!' if the message is sent to \href{mailto:example@fuglu.org}{example@fuglu.org}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{match}\PYG{p}{,}\PYG{n}{arg}\PYG{p}{)}\PYG{o}{=}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{filter}\PYG{o}{.}\PYG{n}{matches}\PYG{p}{(}\PYG{n}{suspect}\PYG{p}{)}
\PYG{k}{if} \PYG{n}{match}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{arg}\PYG{o}{!=}\PYG{n+nb+bp}{None}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{logger}\PYG{o}{.}\PYG{n}{debug}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}\PYG{l+s}{we got a match with arg }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}\PYG{o}{\PYGZpc{}}\PYG{n}{arg}\PYG{p}{)}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{logger}\PYG{o}{.}\PYG{n}{debug}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}\PYG{l+s}{We got a match without an arg}\PYG{l+s}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}\PYG{p}{)}
\PYG{k}{else}\PYG{p}{:}
    \PYG{n}{suspect}\PYG{o}{.}\PYG{n}{debug}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{no rule matches}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\end{Verbatim}


\subsubsection{use the sql extension}
\label{plugins-index:use-the-sql-extension}
TODO (DBFiles, sqlalchemy connections)


\subsection{Debugging}
\label{plugins-index:debugging}

\subsubsection{get a stacktrace}
\label{plugins-index:get-a-stacktrace}
if something went wrong you should see a stacktrace in the fuglu log (/var/log/fuglu/fuglu.log)
with fuglu \textgreater{}=0.6.0 you can also get the most recent exceptions with the following command:

\begin{Verbatim}[commandchars=\\\{\}]
fuglu\_control exceptionlist
\end{Verbatim}


\subsubsection{debug the plugin while fuglu is runnig}
\label{plugins-index:debug-the-plugin-while-fuglu-is-runnig}
run \code{fuglu -{-}console} to enter an interactive python console after fuglu startup. Your plugin is then available via the list \code{mc.plugins}


\subsubsection{debug a plugin without running fuglu}
\label{plugins-index:debug-a-plugin-without-running-fuglu}
\code{plugdummy.py} is a tool that makes plugin development and testing much easier by creating a minimal fuglu environment for the plugin to run. it doesn't require a running fuglu or postfix. it will create a dummy suspect, call the plugin's examine method and print the result (and debug output).

the generated input messag is stored as: \code{/tmp/fuglu\_dummy\_message\_in.eml}

if your plugin modified the message source, the resulting message can be found at \code{/tmp/fuglu\_dummy\_message\_out.eml}

\code{plugdummy.py} is located in the \code{test} directory.

simple usage:

assuming your plugin file (`myplugin.py') is in \code{/usr/local/fuglu/plugins} you can run \code{plugdummy.py \textless{}pluginname\textgreater{}}

\begin{Verbatim}[commandchars=\\\{\}]
\#./plugdummy.py myplugin.ExamplePlugin

INFO:root:Input file created as /tmp/fuglu\_dummy\_message\_in.eml
INFO:root:Running plugin: ExamplePlugin
INFO:fuglu.plugin.ExamplePlugin:sender@fuglu.local greets recipient@fuglu.local: hello world!
INFO:root:Result: DUNNO
INFO:root:Suspect a7babc1e4cfe49c36710065966e6ed0a: from=sender@fuglu.local to=recipient@fuglu.local size=231 spam=no virus=no modified=no tags=\PYGZob{}'virus': \PYGZob{}\PYGZcb{}, 'spam': \PYGZob{}\PYGZcb{}, 'ExamplePlugin.time': '0.0001', 'highspam': \PYGZob{}\PYGZcb{}\PYGZcb{}
\end{Verbatim}

advanced usage:

run \code{plugdummy.py -{-}help} to get a list of all options

Examples:

running plugins from a different directory

\begin{Verbatim}[commandchars=\\\{\}]
./plugdummy.py -p /tmp/ myplugin.ExamplePlugin
\end{Verbatim}

change sender / recipient
the `-s' and `-f' options change the envelope sender/recipient. -r can be specified multiple times to simulate a multi-recipient message

\begin{Verbatim}[commandchars=\\\{\}]
./plugdummy.py -s me@example.org -r you@example.net  myplugin.ExamplePlugin
INFO:root:Input file created as /tmp/fuglu\_dummy\_message\_in.eml
INFO:root:Running plugin: ExamplePlugin
INFO:fuglu.plugin.ExamplePlugin:me@example.org greets you@example.net: hello world!
INFO:root:Result: DUNNO
INFO:root:Suspect 423e02e1461cd1c314ac9a409176c4f4: from=me@example.org to=you@example.net size=221 spam=no virus=no modified=no tags=\PYGZob{}'virus': \PYGZob{}\PYGZcb{}, 'spam': \PYGZob{}\PYGZcb{}, 'ExamplePlugin.time': '0.0001', 'highspam': \PYGZob{}\PYGZcb{}\PYGZcb{}
\end{Verbatim}

adding headers to the input message

\begin{Verbatim}[commandchars=\\\{\}]
./plugdummy.py -h 'subject:yo! whassup' myplugin.ExamplePlugin
[...]
cat /tmp/fuglu\_dummy\_message\_in.eml
Content-Type: text/plain; charset="us-ascii"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
From: sender@fuglu.local
To: recipient@fuglu.local
Subject: yo! whassup
Date: Fri, 01 Jun 2012 12:58:34 -0000

hello, world!
\end{Verbatim}

adding tags:

\begin{Verbatim}[commandchars=\\\{\}]
./plugdummy.py -t 'mytag:myvalue' myplugin.ExamplePlugin
INFO:root:Input file created as /tmp/fuglu\_dummy\_message\_in.eml
INFO:root:Running plugin: ExamplePlugin
INFO:fuglu.plugin.ExamplePlugin:sender@fuglu.local greets recipient@fuglu.local: hello world!
INFO:root:Result: DUNNO
INFO:root:Suspect 168268d6ff2c2748454183efcb554242: from=sender@fuglu.local to=recipient@fuglu.local size=231 spam=no virus=no modified=no tags=\PYGZob{}'spam': \PYGZob{}\PYGZcb{}, 'virus': \PYGZob{}\PYGZcb{}, 'mytag': 'myvalue', 'ExamplePlugin.time': '0.0001', 'highspam': \PYGZob{}\PYGZcb{}\PYGZcb{}
\end{Verbatim}

setting a config option:

\begin{Verbatim}[commandchars=\\\{\}]
./plugdummy.py -o 'greeting:go away!'  myplugin.ExamplePlugin
INFO:root:Input file created as /tmp/fuglu\_dummy\_message\_in.eml
INFO:root:Running plugin: ExamplePlugin
INFO:fuglu.plugin.ExamplePlugin:sender@fuglu.local greets recipient@fuglu.local: go away!
[...]
\end{Verbatim}

setting the message body:

\begin{Verbatim}[commandchars=\\\{\}]
\#set body
./plugdummy.py -b 'hi there, whassup!' myplugin.ExamplePlugin

\#read body from file
./plugdummy.py -b bla.txt myplugin.ExamplePlugin

\#read headers \& body from eml file
./plugdummy.py -e /tmp/bla.eml myplugin.ExamplePlugin
\end{Verbatim}

running a interactive console in the dummy enrivonment:

\begin{Verbatim}[commandchars=\\\{\}]
./plugdummy.py -c  myplugin.ExamplePlugin
INFO:root:Input file created as /tmp/fuglu\_dummy\_message\_in.eml
INFO:root:Running plugin: ExamplePlugin
INFO:fuglu.plugin.ExamplePlugin:sender@fuglu.local greets recipient@fuglu.local: hello world!
INFO:root:Result: DUNNO
INFO:root:Suspect 3cf496cbe2a1097abc37ebda5a645cd2: from=sender@fuglu.local to=recipient@fuglu.local size=231 spam=no virus=no modified=no tags=\PYGZob{}'virus': \PYGZob{}\PYGZcb{}, 'spam': \PYGZob{}\PYGZcb{}, 'ExamplePlugin.time': '0.0001', 'highspam': \PYGZob{}\PYGZcb{}\PYGZcb{}
Fuglu Interactive Console started

pre-defined locals:
\PYGZob{}'config': \textless{}ConfigParser.ConfigParser instance at 0x1ac9e60\textgreater{}, 'suspect': \textless{}fuglu.shared.Suspect object at 0x1ac8750\textgreater{}, 'result': 0, 'plugin': \textless{}myplugin.ExamplePlugin object at 0x1ac8290\textgreater{}\PYGZcb{}

\textgreater{}\textgreater{}\textgreater{} plugin.requiredvars
\PYGZob{}'greeting': \PYGZob{}'default': 'hello world!', 'description': 'greeting the plugin should log to the console'\PYGZcb{}\PYGZcb{}
\textgreater{}\textgreater{}\textgreater{} plugin.examine(suspect)
INFO:fuglu.plugin.ExamplePlugin:sender@fuglu.local greets recipient@fuglu.local: hello world!
0
\textgreater{}\textgreater{}\textgreater{} config.set('ExamplePlugin','greeting','Greetings, Earthling')
\textgreater{}\textgreater{}\textgreater{} suspect.from\_address='me@example.org'
\textgreater{}\textgreater{}\textgreater{} plugin.examine(suspect)
INFO:fuglu.plugin.ExamplePlugin:me@example.org greets recipient@fuglu.local: Greetings, Earthling
0
\textgreater{}\textgreater{}\textgreater{}
\end{Verbatim}


\subsection{Deploying Plugins}
\label{plugins-index:deploying-plugins}\begin{itemize}
\item {} 
if there is no \code{plugindir} set in fuglu.conf yet, define a new directory for custom plugins. eg \code{/usr/local/fuglu/plugins}.

\item {} 
copy your plugin file to this directory

\item {} 
depending on the type of your plugin, add it to the plugin/prependers/appenders config option. Eg. if your scanner plugin class is \code{MyHeloPlugin} in the file myplugin.py you would add \code{myplugin.MyHeloPlugin} to the \code{plugins} config

\item {} 
if your plugin reads configuration entries, make sure those are present in fuglu.conf or in a custom conf-file in /etc/fuglu/conf.d

\item {} 
run \code{fuglu -{-}lint} to check if fuglu is happy with your new plugin

\item {} 
(re)start fuglu

\end{itemize}


\subsection{Unit Tests}
\label{plugins-index:unit-tests}\begin{description}
\item[{You can easily integrate your unittests with the fuglu test script.}] \leavevmode\begin{itemize}
\item {} 
create your testcase in the same file as your plugin resides (the testscript will search for all classes extending unittest.TestCase

\item {} 
create a new directory `\textasciitilde{}/fuglu-dev'

\item {} 
in \textasciitilde{}/fuglu-dev create a new textfile `'test.conf'`

\end{itemize}

\end{description}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{n}{test}\PYG{p}{]}
\PYG{n}{includemodules}\PYG{o}{=}\PYG{n}{myplugin}
\end{Verbatim}

(replace myplugin with your plugin module name)
\begin{itemize}
\item {} 
create a symlink in fuglu-dev to your real plugin file, eg `'ln -s /home/edgar/work/myplugin/myplugin.py \textasciitilde{}/fuglu-dev/myplugin.py'`

\item {} 
checkout the fuglu code from svn

\item {} 
cd to the test directory, then run the testscript with the modulename of your plugin as argument

\end{itemize}

\begin{Verbatim}[commandchars=\\\{\}]
edgar@boscos:\textasciitilde{}/workspace/fuglu/test\$ ./runtests.py myplugin
['../conf/fuglu.conf.dist', '/home/edgar/fuglu-dev/test.conf']
found 1 tests in myplugin
---------------------------
Total 1 tests in Testsuite

STARTING TESTS

fuglu.plugin.MyHeloPlugin: INFO     Hello world from sender@unittests.fuglu.org to recipient@unittests.fuglu.org!
.
----------------------------------------------------------------------
Ran 1 test in 0.010s

OK

Debug Output written to:/tmp/fuglu-test.log
\end{Verbatim}


\chapter{Support}
\label{help-index:support}\label{help-index::doc}
Contents:


\section{FAQ}
\label{help-index:faq}\begin{itemize}
\item {} 
no questions asked frequently yet ;-)

\end{itemize}


\section{Mailing list}
\label{help-index:mailing-list}
\href{http://fuglu.org/mailman/listinfo/fuglu-users\_fuglu.org}{http://fuglu.org/mailman/listinfo/fuglu-users\_fuglu.org}


\chapter{ISP Config}
\label{isp-config::doc}\label{isp-config:isp-config}
So, you are a ISP and consider fuglu as your scan glue? Here's what you need to know.


\section{Quarantine Gui}
\label{isp-config:quarantine-gui}
Fuglu itself does not ship any kind of quarantine web gui (like Mailwatch, Mailguard etc) for a simple reason: the requirements are too diverse. We are pretty sure you would spend the same amount of time adapting our gui to your needs as writing it from scratch.

A few examples:
\begin{itemize}
\item {} 
programming language used in the web environment (python, php,perl, ....)

\item {} 
ACL concepts

\item {} 
some have a concept of ``alias domains'', some don't

\item {} 
different antispam/antivirus backends

\item {} 
different types of quarantine storage
* distributed on scanning machine like mailscanner
* centralized nfs
* stored in a Cassandra/CouchDB cluster, ...)

\item {} 
different types of reports (some want to show every detail to their clients, some others just want them to see number of  spam/ham/virus, etc)

\item {} 
CRM/ERP integration

\end{itemize}

We recommend you write your user interface the way you like and then let fuglu's plugin system interface to your gui, usually via a database.


\section{The fuglu ISP plugin}
\label{isp-config:the-fuglu-isp-plugin}
Your quarantine gui probaly reads some sort of maillog table which contains a list of all received messages.
In fuglu you'd write a plugin which fills this table.

Below is a stripped down example of such a plugin. In a real setup you'd probably have more database fields, add blacklist/whitelist capabilities and support for per domain/per user configuration overrides.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} \PYGZhy{}*\PYGZhy{} coding: UTF\PYGZhy{}8 \PYGZhy{}*\PYGZhy{}}

\PYG{k+kn}{from} \PYG{n+nn}{fuglu.shared} \PYG{k+kn}{import} \PYG{n}{ScannerPlugin}\PYG{p}{,}\PYG{n}{DELETE}\PYG{p}{,}\PYG{n}{DUNNO}\PYG{p}{,}\PYG{n}{DEFER}\PYG{p}{,}\PYG{n}{Suspect}\PYG{p}{,}\PYG{n}{string\PYGZus{}to\PYGZus{}actioncode}
\PYG{k+kn}{import} \PYG{n+nn}{time}
\PYG{k+kn}{import} \PYG{n+nn}{datetime}
\PYG{k+kn}{import} \PYG{n+nn}{os}
\PYG{k+kn}{import} \PYG{n+nn}{fuglu.extensions.sql}
\PYG{k+kn}{import} \PYG{n+nn}{re}

\PYG{k+kn}{from} \PYG{n+nn}{sqlalchemy} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{k+kn}{from} \PYG{n+nn}{sqlalchemy.ext.declarative} \PYG{k+kn}{import} \PYG{n}{declarative\PYGZus{}base}
\PYG{k+kn}{import} \PYG{n+nn}{logging}

\PYG{k+kn}{import} \PYG{n+nn}{socket}
\PYG{n}{MYHOSTNAME}\PYG{o}{=}\PYG{n}{socket}\PYG{o}{.}\PYG{n}{gethostname}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{DeclarativeBase} \PYG{o}{=} \PYG{n}{declarative\PYGZus{}base}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{metadata} \PYG{o}{=} \PYG{n}{DeclarativeBase}\PYG{o}{.}\PYG{n}{metadata}

\PYG{n}{maillog} \PYG{o}{=} \PYG{n}{Table}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{maillog}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{metadata}\PYG{p}{,}
    \PYG{n}{Column}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{fugluid}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{Unicode}\PYG{p}{(}\PYG{l+m+mi}{255}\PYG{p}{)}\PYG{p}{,} \PYG{n}{primary\PYGZus{}key}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}\PYG{p}{,}
    \PYG{n}{Column}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{subject}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{Unicode}\PYG{p}{(}\PYG{l+m+mi}{255}\PYG{p}{)}\PYG{p}{,}\PYG{n}{nullable}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}\PYG{p}{,}
    \PYG{n}{Column}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{from\PYGZus{}address}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{Unicode}\PYG{p}{(}\PYG{l+m+mi}{255}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
    \PYG{n}{Column}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{to\PYGZus{}address}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{Unicode}\PYG{p}{(}\PYG{l+m+mi}{255}\PYG{p}{)}\PYG{p}{,}\PYG{n}{nullable}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}\PYG{p}{,}
    \PYG{n}{Column}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{from\PYGZus{}domain}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{Unicode}\PYG{p}{(}\PYG{l+m+mi}{255}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
    \PYG{n}{Column}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{to\PYGZus{}domain}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{Unicode}\PYG{p}{(}\PYG{l+m+mi}{255}\PYG{p}{)}\PYG{p}{,}\PYG{n}{nullable}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}\PYG{p}{,}
    \PYG{n}{Column}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{spam}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{Boolean}\PYG{p}{,} \PYG{n}{default}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}\PYG{p}{,}
    \PYG{n}{Column}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{highspam}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{Boolean}\PYG{p}{,} \PYG{n}{default}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}\PYG{p}{,}
    \PYG{n}{Column}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{virus}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{Boolean}\PYG{p}{,} \PYG{n}{default}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}\PYG{p}{,}
    \PYG{n}{Column}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{date}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{Date}\PYG{p}{,} \PYG{n}{nullable}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}\PYG{p}{,}
    \PYG{n}{Column}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{time}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{TIME}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{,} \PYG{n}{nullable}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}\PYG{p}{,}
    \PYG{n}{Column}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{headers}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{UnicodeText}\PYG{p}{,} \PYG{n}{nullable}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}\PYG{p}{,}
    \PYG{n}{Column}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{size}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{Integer}\PYG{p}{,}\PYG{n}{nullable}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}\PYG{p}{,}
    \PYG{n}{Column}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{messageid}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{Unicode}\PYG{p}{(}\PYG{l+m+mi}{255}\PYG{p}{)}\PYG{p}{,}\PYG{n}{nullable}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}\PYG{p}{,}
    \PYG{n}{Column}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{spamrules}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{TEXT}\PYG{p}{,} \PYG{n}{nullable}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}\PYG{p}{,}
    \PYG{n}{Column}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{virusinfo}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{TEXT}\PYG{p}{,} \PYG{n}{nullable}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}\PYG{p}{,}
    \PYG{n}{Column}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{blockedfile}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{Boolean}\PYG{p}{,} \PYG{n}{nullable}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{,} \PYG{n}{default}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}\PYG{p}{,}
    \PYG{n}{Column}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{blockinfo}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{TEXT}\PYG{p}{,} \PYG{n}{nullable}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}\PYG{p}{,}
    \PYG{n}{Column}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{sascore}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{Float}\PYG{p}{,} \PYG{n}{nullable}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}\PYG{p}{,}
    \PYG{n}{Column}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{quarantined}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{Boolean}\PYG{p}{,} \PYG{n}{nullable}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{,} \PYG{n}{default}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}\PYG{p}{,}
    \PYG{n}{Column}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{sascantime}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{Float}\PYG{p}{,} \PYG{n}{nullable}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}\PYG{p}{,}
    \PYG{n}{Column}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{scanhost}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{Unicode}\PYG{p}{(}\PYG{l+m+mi}{255}\PYG{p}{)}\PYG{p}{,}\PYG{n}{nullable}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}\PYG{p}{,}
    \PYG{n}{mysql\PYGZus{}engine}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{InnoDB}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}
    \PYG{n}{mysql\PYGZus{}charset}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{utf8}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}
\PYG{p}{)}


\PYG{k}{class} \PYG{n+nc}{ISPPlugin}\PYG{p}{(}\PYG{n}{ScannerPlugin}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}ISP Demo Plugin\PYGZdq{}\PYGZdq{}\PYGZdq{}}

    \PYG{k}{def} \PYG{n+nf}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{config}\PYG{p}{,}\PYG{n}{section}\PYG{o}{=}\PYG{n+nb+bp}{None}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{ScannerPlugin}\PYG{o}{.}\PYG{n}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{config}\PYG{p}{,}\PYG{n}{section}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{logger}\PYG{o}{=}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}logger}\PYG{p}{(}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{requiredvars}\PYG{o}{=}\PYG{p}{(}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{section}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{dbconnectstring}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}\PYG{p}{)}


    \PYG{k}{def} \PYG{n+nf}{needquarantine}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{suspect}\PYG{p}{)}\PYG{p}{:}
        \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}return True if message should be quarantined\PYGZdq{}\PYGZdq{}\PYGZdq{}}
        \PYG{k}{if} \PYG{n}{suspect}\PYG{o}{.}\PYG{n}{get\PYGZus{}tag}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{debug}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:}
            \PYG{k}{return} \PYG{n+nb+bp}{False}

        \PYG{c}{\PYGZsh{}infected mails can\PYGZsq{}t be whitelisted}
        \PYG{k}{if} \PYG{n}{suspect}\PYG{o}{.}\PYG{n}{is\PYGZus{}virus}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
            \PYG{k}{return} \PYG{n+nb+bp}{True}

        \PYG{c}{\PYGZsh{}blocked attachments can\PYGZsq{}t be whitelisted}
        \PYG{n}{blockinfo}\PYG{o}{=}\PYG{n}{suspect}\PYG{o}{.}\PYG{n}{get\PYGZus{}tag}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{FiletypePlugin.errormessage}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
        \PYG{k}{if} \PYG{n}{blockinfo}\PYG{o}{!=}\PYG{n+nb+bp}{None}\PYG{p}{:}
            \PYG{k}{return} \PYG{n+nb+bp}{True}

        \PYG{c}{\PYGZsh{}whitelisted \PYGZhy{}\PYGZgt{} no quarantine}
        \PYG{c}{\PYGZsh{}assuming you have a prevous plugin which sets a \PYGZsq{}whitelisted\PYGZsq{} tag}
        \PYG{k}{if} \PYG{n}{suspect}\PYG{o}{.}\PYG{n}{get\PYGZus{}tag}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{whitelisted}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:}
            \PYG{k}{return} \PYG{n+nb+bp}{False}

        \PYG{c}{\PYGZsh{}blacklisted \PYGZhy{}\PYGZgt{} quarantine}
        \PYG{c}{\PYGZsh{}assuming you have a previous plugin which sets a \PYGZsq{}blacklisted\PYGZsq{} tag}
        \PYG{k}{if} \PYG{n}{suspect}\PYG{o}{.}\PYG{n}{get\PYGZus{}tag}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{blacklisted}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:}
            \PYG{k}{return} \PYG{n+nb+bp}{True}

        \PYG{c}{\PYGZsh{}spam \PYGZhy{}\PYGZgt{} quarantine}
        \PYG{p}{(}\PYG{n}{spam}\PYG{p}{,}\PYG{n}{highspam}\PYG{p}{)}\PYG{o}{=}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{is\PYGZus{}spam\PYGZus{}highspam}\PYG{p}{(}\PYG{n}{suspect}\PYG{p}{)}
        \PYG{k}{if} \PYG{n}{spam} \PYG{o+ow}{or} \PYG{n}{highspam}\PYG{p}{:}
            \PYG{k}{return} \PYG{n+nb+bp}{True}

        \PYG{c}{\PYGZsh{}ham \PYGZhy{}\PYGZgt{} no quarantine}
        \PYG{k}{return} \PYG{n+nb+bp}{False}

    \PYG{k}{def} \PYG{n+nf}{should\PYGZus{}tag\PYGZus{}and\PYGZus{}send}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{suspect}\PYG{p}{)}\PYG{p}{:}
        \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}return true if message should be tagged and sent to the recipient\PYGZdq{}\PYGZdq{}\PYGZdq{}}

        \PYG{k}{if} \PYG{n}{suspect}\PYG{o}{.}\PYG{n}{is\PYGZus{}virus}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
            \PYG{k}{return} \PYG{n+nb+bp}{False}

        \PYG{n}{blockinfo}\PYG{o}{=}\PYG{n}{suspect}\PYG{o}{.}\PYG{n}{get\PYGZus{}tag}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{FiletypePlugin.errormessage}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
        \PYG{k}{if} \PYG{n}{blockinfo}\PYG{o}{!=}\PYG{n+nb+bp}{None}\PYG{p}{:}
            \PYG{k}{return} \PYG{n+nb+bp}{False}

        \PYG{k}{if} \PYG{n}{suspect}\PYG{o}{.}\PYG{n}{get\PYGZus{}tag}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{blacklisted}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:}
            \PYG{k}{return} \PYG{n+nb+bp}{False}

        \PYG{p}{(}\PYG{n}{spam}\PYG{p}{,}\PYG{n}{highspam}\PYG{p}{)}\PYG{o}{=}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{is\PYGZus{}spam\PYGZus{}highspam}\PYG{p}{(}\PYG{n}{suspect}\PYG{p}{)}

        \PYG{c}{\PYGZsh{}here you could load user/domain individual configs and check if they have disabled the quarantine}
        \PYG{c}{\PYGZsh{}conf=get\PYGZus{}filter\PYGZus{}config(suspect,self.config.get(self.section,\PYGZsq{}dbconnectstring\PYGZsq{}))}
        \PYG{c}{\PYGZsh{}if (spam and conf.deliverspam) or (highspam and conf.deliverhighspam):}
        \PYG{c}{\PYGZsh{}    return True}

        \PYG{c}{\PYGZsh{}fallback if quarantine was not available (set by examine method)}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{spam} \PYG{o+ow}{or} \PYG{n}{highspam}\PYG{p}{)} \PYG{o+ow}{and} \PYG{n}{suspect}\PYG{o}{.}\PYG{n}{get\PYGZus{}tag}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{tagandsend}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{:}
            \PYG{k}{return} \PYG{n+nb+bp}{True}

        \PYG{k}{return} \PYG{n+nb+bp}{False}

    \PYG{k}{def} \PYG{n+nf}{examine}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{suspect}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{starttime}\PYG{o}{=}\PYG{n}{time}\PYG{o}{.}\PYG{n}{time}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{suspect}\PYG{o}{.}\PYG{n}{set\PYGZus{}tag}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{ispquar}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n+nb+bp}{False}\PYG{p}{)}
        \PYG{n}{action}\PYG{o}{=}\PYG{n}{DUNNO}
        \PYG{k}{if} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{needquarantine}\PYG{p}{(}\PYG{n}{suspect}\PYG{p}{)}\PYG{p}{:}
            \PYG{k}{try}\PYG{p}{:}
                \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{quarantine}\PYG{p}{(}\PYG{n}{suspect}\PYG{p}{)}
                \PYG{n}{suspect}\PYG{o}{.}\PYG{n}{set\PYGZus{}tag}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{ispquar}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n+nb+bp}{True}\PYG{p}{)}
                \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{logger}\PYG{o}{.}\PYG{n}{info}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{message quarantined: }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{n}{suspect}\PYG{o}{.}\PYG{n}{id}\PYG{p}{)}
                \PYG{n}{action}\PYG{o}{=}\PYG{n}{DELETE}
            \PYG{k}{except} \PYG{n+ne}{Exception}\PYG{p}{,}\PYG{n}{e}\PYG{p}{:}
                \PYG{k}{try}\PYG{p}{:}
                    \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{logger}\PYG{o}{.}\PYG{n}{warn}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{quarantine failed}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
                    \PYG{c}{\PYGZsh{}you could use a fallback mechanism here, eg. store in a local directory}
                \PYG{k}{except} \PYG{n+ne}{Exception}\PYG{p}{,}\PYG{n}{e}\PYG{p}{:}
                    \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{logger}\PYG{o}{.}\PYG{n}{error}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Could not quarantine message }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{ : }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{ \PYGZhy{}\PYGZgt{} fallback to tag and send}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{suspect}\PYG{o}{.}\PYG{n}{id}\PYG{p}{,}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{e}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
                    \PYG{n}{suspect}\PYG{o}{.}\PYG{n}{set\PYGZus{}tag}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{tagandsend}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n+nb+bp}{True}\PYG{p}{)}

        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{maillog}\PYG{p}{(}\PYG{n}{suspect}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{logger}\PYG{o}{.}\PYG{n}{info}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{suspect }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{ logged to database}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{n}{suspect}\PYG{o}{.}\PYG{n}{id}\PYG{p}{)}

        \PYG{c}{\PYGZsh{}check for tag\PYGZam{}send}
        \PYG{k}{if} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{should\PYGZus{}tag\PYGZus{}and\PYGZus{}send}\PYG{p}{(}\PYG{n}{suspect}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{suspect}\PYG{o}{.}\PYG{n}{set\PYGZus{}tag}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{tagandsend}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n+nb+bp}{True}\PYG{p}{)}
            \PYG{n}{action}\PYG{o}{=}\PYG{n}{DUNNO}
            \PYG{n}{tag}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{*** SPAM ***}\PYG{l+s}{\PYGZdq{}}
            \PYG{n}{msgrep}\PYG{o}{=}\PYG{n}{suspect}\PYG{o}{.}\PYG{n}{getMessageRep}\PYG{p}{(}\PYG{p}{)}
            \PYG{n}{oldsubj}\PYG{o}{=}\PYG{n}{msgrep}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{subject}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
            \PYG{n}{newsubj}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{tag}\PYG{p}{,}\PYG{n}{oldsubj}\PYG{p}{)}
            \PYG{k}{del} \PYG{n}{msgrep}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{subject}\PYG{l+s}{\PYGZdq{}}\PYG{p}{]}
            \PYG{n}{msgrep}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{subject}\PYG{l+s}{\PYGZdq{}}\PYG{p}{]}\PYG{o}{=}\PYG{n}{newsubj}
            \PYG{n}{suspect}\PYG{o}{.}\PYG{n}{setMessageRep}\PYG{p}{(}\PYG{n}{msgrep}\PYG{p}{)}

        \PYG{n}{endtime}\PYG{o}{=}\PYG{n}{time}\PYG{o}{.}\PYG{n}{time}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{difftime}\PYG{o}{=}\PYG{n}{endtime}\PYG{o}{\PYGZhy{}}\PYG{n}{starttime}
        \PYG{n}{suspect}\PYG{o}{.}\PYG{n}{tags}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{ISPPlugin.time}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+si}{\PYGZpc{}.4f}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZpc{}}\PYG{n}{difftime}
        \PYG{k}{return} \PYG{n}{action}


    \PYG{k}{def} \PYG{n+nf}{quarantine}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{suspect}\PYG{p}{)}\PYG{p}{:}
        \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Store message source into quarantine\PYGZdq{}\PYGZdq{}\PYGZdq{}}
        \PYG{k}{if} \PYG{n}{suspect}\PYG{o}{.}\PYG{n}{get\PYGZus{}tag}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{debug}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:}
            \PYG{k}{return}

        \PYG{c}{\PYGZsh{}your code here to store the message source in your quarantine (local file, database, ....)}


    \PYG{k}{def} \PYG{n+nf}{maillog}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{suspect}\PYG{p}{)}\PYG{p}{:}
        \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Log this message into a mysql database table\PYGZdq{}\PYGZdq{}\PYGZdq{}}
        \PYG{k}{if} \PYG{n}{suspect}\PYG{o}{.}\PYG{n}{get\PYGZus{}tag}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{debug}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:}
            \PYG{k}{return}
        \PYG{n}{msgrep}\PYG{o}{=}\PYG{n}{suspect}\PYG{o}{.}\PYG{n}{getMessageRep}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{headers}\PYG{o}{=}\PYG{n}{re}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{(?:}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{)\textbar{}(?:}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{)}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{suspect}\PYG{o}{.}\PYG{n}{getSource}\PYG{p}{(}\PYG{n}{maxbytes}\PYG{o}{=}\PYG{l+m+mi}{1048576}\PYG{p}{)}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
        \PYG{n}{subj}\PYG{o}{=}\PYG{n}{msgrep}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{X\PYGZhy{}Spam\PYGZhy{}Prev\PYGZhy{}Subject}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
        \PYG{k}{if} \PYG{n}{subj}\PYG{o}{==}\PYG{n+nb+bp}{None}\PYG{p}{:}
            \PYG{n}{subj}\PYG{o}{=}\PYG{n}{msgrep}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Subject}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
        \PYG{k}{if} \PYG{n}{subj}\PYG{o}{==}\PYG{n+nb+bp}{None}\PYG{p}{:}
            \PYG{n}{subj}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZsq{}}

        \PYG{k}{try}\PYG{p}{:}
            \PYG{n}{subj}\PYG{o}{=}\PYG{n}{subj}\PYG{o}{.}\PYG{n}{decode}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{utf8}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{replace}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
        \PYG{k}{except}\PYG{p}{:}
            \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{logger}\PYG{o}{.}\PYG{n}{warning}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Could not decode subject \PYGZhy{} may be truncated}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}

        \PYG{n}{ts}\PYG{o}{=}\PYG{n}{suspect}\PYG{o}{.}\PYG{n}{timestamp}
        \PYG{n}{dt}\PYG{o}{=}\PYG{n}{datetime}\PYG{o}{.}\PYG{n}{datetime}\PYG{o}{.}\PYG{n}{fromtimestamp}\PYG{p}{(}\PYG{n}{ts}\PYG{p}{)}
        \PYG{n}{datenow}\PYG{o}{=}\PYG{n}{dt}\PYG{o}{.}\PYG{n}{date}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{timenow}\PYG{o}{=}\PYG{n}{dt}\PYG{o}{.}\PYG{n}{time}\PYG{p}{(}\PYG{p}{)}

        \PYG{n}{session}\PYG{o}{=}\PYG{n}{fuglu}\PYG{o}{.}\PYG{n}{extensions}\PYG{o}{.}\PYG{n}{sql}\PYG{o}{.}\PYG{n}{get\PYGZus{}session}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{config}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{section}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{dbconnectstring}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{metadata}\PYG{o}{.}\PYG{n}{bind}\PYG{o}{=}\PYG{n}{session}

        \PYG{c}{\PYGZsh{}we can\PYGZsq{}t use suspect.is\PYGZus{}spam here since spamassassin or other plugins}
        \PYG{c}{\PYGZsh{}(maybe) don\PYGZsq{}t know about individual isp user settings}
        \PYG{n}{spam}\PYG{p}{,}\PYG{n}{highspam}\PYG{o}{=}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{is\PYGZus{}spam\PYGZus{}highspam}\PYG{p}{(}\PYG{n}{suspect}\PYG{p}{)}

        \PYG{c}{\PYGZsh{}file block info}
        \PYG{n}{blocked}\PYG{o}{=}\PYG{n+nb+bp}{False}
        \PYG{n}{blockinfo}\PYG{o}{=}\PYG{n}{suspect}\PYG{o}{.}\PYG{n}{get\PYGZus{}tag}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{FiletypePlugin.errormessage}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
        \PYG{k}{if} \PYG{n}{blockinfo}\PYG{o}{!=}\PYG{n+nb+bp}{None}\PYG{p}{:}
            \PYG{n}{blocked}\PYG{o}{=}\PYG{n+nb+bp}{True}

        \PYG{n}{messageid}\PYG{o}{=}\PYG{n}{msgrep}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Message\PYGZhy{}Id}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}


        \PYG{c}{\PYGZsh{}spam rules}
        \PYG{n}{ruletext}\PYG{o}{=}\PYG{n}{suspect}\PYG{o}{.}\PYG{n}{get\PYGZus{}tag}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{SAPlugin.report}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

        \PYG{c}{\PYGZsh{}virusinfo: only virusnames separated by space}
        \PYG{n}{allviruses}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}

        \PYG{c}{\PYGZsh{}clam}
        \PYG{n}{claminfo}\PYG{o}{=}\PYG{n}{suspect}\PYG{o}{.}\PYG{n}{get\PYGZus{}tag}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{ClamavPlugin.virus}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
        \PYG{k}{if} \PYG{n}{claminfo}\PYG{o}{!=}\PYG{n+nb+bp}{None}\PYG{p}{:}
            \PYG{k}{for} \PYG{n}{infectedfile}\PYG{p}{,}\PYG{n}{virusname} \PYG{o+ow}{in} \PYG{n}{claminfo}\PYG{o}{.}\PYG{n}{iteritems}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{allviruses}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{virusname}\PYG{p}{)}

        \PYG{c}{\PYGZsh{} add other virus scanners here}

        \PYG{c}{\PYGZsh{}remove duplicate viruses}
        \PYG{n}{univiruses}\PYG{o}{=}\PYG{n+nb}{set}\PYG{p}{(}\PYG{n}{allviruses}\PYG{p}{)}

        \PYG{c}{\PYGZsh{}remove spaces in virusnames and concatenate into single string}
        \PYG{n}{virusinfo}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZdq{}}
        \PYG{k}{for} \PYG{n}{virusname} \PYG{o+ow}{in} \PYG{n}{univiruses}\PYG{p}{:}
            \PYG{n}{virusname}\PYG{o}{=}\PYG{n}{virusname}\PYG{o}{.}\PYG{n}{replace}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZus{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{strip}\PYG{p}{(}\PYG{p}{)}
            \PYG{n}{virusinfo}\PYG{o}{=}\PYG{n}{virusinfo}\PYG{o}{+}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{virusname}
        \PYG{n}{virusinfo}\PYG{o}{=}\PYG{n}{virusinfo}\PYG{o}{.}\PYG{n}{strip}\PYG{p}{(}\PYG{p}{)}

        \PYG{c}{\PYGZsh{}spamscore}
        \PYG{k}{try}\PYG{p}{:}
            \PYG{n}{sascore}\PYG{o}{=}\PYG{n+nb}{float}\PYG{p}{(}\PYG{n}{suspect}\PYG{o}{.}\PYG{n}{get\PYGZus{}tag}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{SAPlugin.spamscore}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
        \PYG{k}{except}\PYG{p}{:}
            \PYG{n}{sascore}\PYG{o}{=}\PYG{n+nb+bp}{None}

        \PYG{k}{try}\PYG{p}{:}
            \PYG{n}{headers}\PYG{o}{=}\PYG{n}{headers}\PYG{o}{.}\PYG{n}{decode}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{utf8}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{replace}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
        \PYG{k}{except} \PYG{n+ne}{Exception}\PYG{p}{,}\PYG{n}{e}\PYG{p}{:}
            \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{logger}\PYG{o}{.}\PYG{n}{warning}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Could not decode headers to utf8 \PYGZhy{} output may be truncated}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}

        \PYG{n}{scantime}\PYG{o}{=}\PYG{n}{suspect}\PYG{o}{.}\PYG{n}{get\PYGZus{}tag}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{SAPlugin.time}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
        \PYG{k}{if} \PYG{n}{scantime}\PYG{o}{!=}\PYG{n+nb+bp}{None}\PYG{p}{:}
            \PYG{k}{try}\PYG{p}{:}
                \PYG{n}{scantime}\PYG{o}{=}\PYG{n+nb}{float}\PYG{p}{(}\PYG{n}{scantime}\PYG{p}{)}
            \PYG{k}{except}\PYG{p}{:}
                \PYG{n}{scantime}\PYG{o}{=}\PYG{n+nb+bp}{None}

        \PYG{n}{data}\PYG{o}{=}\PYG{p}{\PYGZob{}}
             \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{fugluid}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{n}{suspect}\PYG{o}{.}\PYG{n}{id}\PYG{o}{.}\PYG{n}{decode}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
             \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{from\PYGZus{}address}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{n}{suspect}\PYG{o}{.}\PYG{n}{from\PYGZus{}address}\PYG{o}{.}\PYG{n}{decode}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
             \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{to\PYGZus{}address}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{n}{suspect}\PYG{o}{.}\PYG{n}{to\PYGZus{}address}\PYG{o}{.}\PYG{n}{decode}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
             \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{from\PYGZus{}domain}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{n}{suspect}\PYG{o}{.}\PYG{n}{from\PYGZus{}domain}\PYG{o}{.}\PYG{n}{decode}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
             \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{to\PYGZus{}domain}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{n}{suspect}\PYG{o}{.}\PYG{n}{to\PYGZus{}domain}\PYG{o}{.}\PYG{n}{decode}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
             \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{date}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{n}{datenow}\PYG{p}{,}
             \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{time}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{n}{timenow}\PYG{p}{,}
             \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{spam}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{n}{spam}\PYG{p}{,}
             \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{highspam}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{n}{highspam}\PYG{p}{,}
             \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{virus}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{n}{suspect}\PYG{o}{.}\PYG{n}{is\PYGZus{}virus}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
             \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{size}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{n}{suspect}\PYG{o}{.}\PYG{n}{size}\PYG{p}{,}
             \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{subject}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{n}{subj}\PYG{p}{,}
             \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{headers}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{n}{headers}\PYG{p}{,}
             \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{messageid}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{n}{messageid}\PYG{p}{,}
             \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{virusinfo}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{n}{virusinfo}\PYG{p}{,}
             \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{sascore}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{n}{sascore}\PYG{p}{,}
             \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{blockedfile}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{n}{blocked}\PYG{p}{,}
             \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{blockinfo}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{n}{blockinfo}\PYG{p}{,}
             \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{quarantined}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{n}{suspect}\PYG{o}{.}\PYG{n}{get\PYGZus{}tag}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{ispquar}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{==}\PYG{n+nb+bp}{True}\PYG{p}{,}
             \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{scanhost}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{n}{MYHOSTNAME}\PYG{p}{,}
             \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{sascantime}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{n}{scantime}\PYG{p}{,}
             \PYG{c}{\PYGZsh{} more fields here....}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{session}\PYG{o}{.}\PYG{n}{execute}\PYG{p}{(}\PYG{n}{maillog}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{values}\PYG{p}{(}\PYG{o}{*}\PYG{o}{*}\PYG{n}{data}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{session}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}




    \PYG{k}{def} \PYG{n+nf}{is\PYGZus{}spam\PYGZus{}highspam}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{suspect}\PYG{p}{)}\PYG{p}{:}
        \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Returns a tuple bool,bool for spam/highspam according to user or domain sa thresholds\PYGZdq{}\PYGZdq{}\PYGZdq{}}
        \PYG{k}{if} \PYG{n}{suspect}\PYG{o}{.}\PYG{n}{get\PYGZus{}tag}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{whitelisted}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:}
            \PYG{k}{return} \PYG{p}{(}\PYG{n+nb+bp}{False}\PYG{p}{,}\PYG{n+nb+bp}{False}\PYG{p}{)}

        \PYG{k}{try}\PYG{p}{:}
            \PYG{n}{score}\PYG{o}{=}\PYG{n+nb}{float}\PYG{p}{(} \PYG{n}{suspect}\PYG{o}{.}\PYG{n}{get\PYGZus{}tag}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{SAPlugin.spamscore}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
        \PYG{k}{except} \PYG{n+ne}{Exception}\PYG{p}{,}\PYG{n}{e}\PYG{p}{:}
            \PYG{c}{\PYGZsh{}subject was not sa scanned}
            \PYG{k}{return} \PYG{p}{(}\PYG{n+nb+bp}{False}\PYG{p}{,}\PYG{n+nb+bp}{False}\PYG{p}{)}

        \PYG{c}{\PYGZsh{}here you would load per user/per domain individual spam scores}
        \PYG{c}{\PYGZsh{} user\PYGZus{}scpamscore= ...}
        \PYG{c}{\PYGZsh{} user\PYGZus{}highspamscore= ...}

        \PYG{n}{spam}\PYG{o}{=}\PYG{n+nb+bp}{False}
        \PYG{n}{highspam}\PYG{o}{=}\PYG{n+nb+bp}{False}

        \PYG{k}{if} \PYG{n}{score}\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{n}{user\PYGZus{}spamscore}\PYG{p}{:}
            \PYG{n}{spam}\PYG{o}{=}\PYG{n+nb+bp}{True}

        \PYG{k}{if} \PYG{n}{score}\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{n}{user\PYGZus{}highspamscore}\PYG{p}{:}
            \PYG{n}{highspam}\PYG{o}{=}\PYG{n+nb+bp}{True}

        \PYG{k}{return} \PYG{p}{(}\PYG{n}{spam}\PYG{p}{,}\PYG{n}{highspam}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{\PYGZus{}\PYGZus{}str\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{l+s}{u\PYGZsq{}}\PYG{l+s}{ISP Quarantine/Maillog}\PYG{l+s}{\PYGZsq{}}\PYG{p}{;}
\end{Verbatim}


\section{Configuration of other plugins}
\label{isp-config:configuration-of-other-plugins}
in a ISP setup, your ISP Plugin should be the only one making decisions ( forward / delete ...) based on the results of other plugins.

in your fuglu.conf you'd probably set:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{n}{spam}\PYG{p}{]}
\PYG{n}{defaultlowspamaction}\PYG{o}{=}\PYG{n}{DUNNO}
\PYG{n}{defaulthighspamaction}\PYG{o}{=}\PYG{n}{DUNNO}

\PYG{p}{[}\PYG{n}{virus}\PYG{p}{]}
\PYG{n}{defaultvirusaction}\PYG{o}{=}\PYG{n}{DUNNO}
\end{Verbatim}

also, make sure the ISP Plugin is the last plugin

\begin{Verbatim}[commandchars=\\\{\}]
[main]
plugins=attachment,clamav,\textless{}other virus scanners here\textgreater{},spamassassin,\textless{}your isp plugin\textgreater{}
\end{Verbatim}

so, in case of an infected message, the virus scanner plugins would tag the message as virus but hand it over to later plugins anyway. your isp plugin then reads the tag and returns ``DELETE'' after the infected message has been quarantined.


\chapter{Indices and tables}
\label{index:indices-and-tables}\begin{itemize}
\item {} 
\emph{genindex}

\item {} 
\emph{modindex}

\item {} 
\emph{search}

\end{itemize}



\renewcommand{\indexname}{Index}
\printindex
\end{document}
